<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SQL注入笔记</title>
    <url>/blog/2020/06/01/SQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>Sql 注入是渗透测试中的一个重要部分。这里是一些 Sql 注入相关内容的总结和整理，留待以后查阅。</p>
<a id="more"></a>
<h2 id="Sql-注入的本质理解">Sql 注入的本质理解</h2>
<p>Sql 注入的本质是利用网页中可控的注入点，动态构造后端的 Sql 语句，达到注入攻击的目的。（从客户端提交特殊的代码，从而收集程序及服务器的信息，从而获取想得到的资料。）</p>
<h2 id="Sql-注入的一般步骤">Sql 注入的一般步骤</h2>
<ol>
<li>判断环境、寻找注入点、判断数据库类型。</li>
<li>根据注入参数类型，在脑海中构造大致的 Sql 语句。
<ul>
<li>数字型：<code>Select * from 表名 where id=1 and [查询条件]</code> （注入参数为<code>id=1 and [查询条件]</code>）</li>
<li>字符型：<code>select * from 表名 where class='a' and [查询条件] and ''=''</code>（注入参数为<code>class=a' and [查询条件] and ''='</code>）</li>
<li>搜索型：SQL 语句原貌大致为：<code>Select * from 表名 where 字段 like '%关键字%'</code> ,生成语句可以是<code>Select * from 表名 where 字段 like '%' and [查询条件] and '%'='%'</code> （注入参数为<code>keyword=' and [查询条件] and '%25'='</code>）（语句中的 ‘%’ 意为模糊查询，%25 经 URL 解码后为 ‘%’ ）</li>
</ul>
</li>
<li>猜解表名，列名，查找需要的数据。</li>
</ol>
<h2 id="Sql-注入点的判断">Sql 注入点的判断</h2>
<h3 id="常见注入点">常见注入点</h3>
<ul>
<li>
<p>GET 请求：在 URL 中发送参数。</p>
</li>
<li>
<p>POST 请求：数据被包含在请求体中。</p>
</li>
<li>
<p><strong>其它类型的注入数据：例如 HTTP 请求头等</strong></p>
<p>常见 http 可能被污染的参数:</p>
<ul>
<li>User-agent 浏览器版本 （少）</li>
<li>Referer 来源（少）</li>
<li>X-Forwarded-For 获取 ip（多）</li>
<li>client_ip 获取 ip（多）</li>
<li>cookie 获取 cookie 值（多）</li>
</ul>
</li>
</ul>
<h3 id="注入点判断方法">注入点判断方法</h3>
<h4 id="返回错误信息">返回错误信息</h4>
<p><strong>单引号判断法：</strong></p>
<p>在参数后面加上单引号并观察。<strong>如果页面返回错误，则存在 Sql 注入</strong>，即存在可被我们控制的动态构造部分。 原因是<strong>无论字符型还是整型都会因为单引号个数不匹配而报错</strong>。出现单引号个数不匹配说明某部分后端代码用我们提供的多一个引号的参数动态构造后多出了一个引号。同时，这种方法在页面出现错误信息的时候也可以判断数据库类型。</p>
<p><em>实例：</em></p>
<blockquote>
<p>在网站首页上，有名为“IE 不能打开新窗口的多种解决方法”的链接，地址为：<code>http://www.mytest.com/showdetail.asp?id=49</code>，我们在这个地址后面加上单引号’，服务器返回下面的错误提示：</p>
<blockquote>
<p>Microsoft JET Database Engine 错误 ‘80040e14’</p>
<p>字符串的语法错误 在查询表达式 ‘ID=49’’ 中。<br>
/showdetail.asp，行 8</p>
</blockquote>
<p><strong>从这个错误提示我们能看出：</strong></p>
<ul>
<li>网站使用的是 Access 数据库，通过 JET 引擎连接数据库，而不是通过 ODBC。 //引擎及数据库信息</li>
<li>程序没有判断客户端提交的数据是否符合程序要求。 //对注入的可能性的判断</li>
<li>该 SQL 语句所查询的表中有一名为 ID 的字段。 //对字段的判断</li>
</ul>
</blockquote>
<h4 id="不返回错误信息">不返回错误信息</h4>
<p>上述的单引号判断法简便易用，但并不适用于所有的情况，具体解释如下：</p>
<blockquote>
<p>1.不一定每台服务器的 IIS 都返回具体错误提示给客户端，如果程序中加了 cint(参数)之类语句的话，Sql 注入是不会成功的，但服务器同样会报错，具体提示信息为处理 URL 时服务器上出错。请和系统管理员联络。 2.部分对 Sql 注入有一点了解的程序员，认为只要把单引号过滤掉就安全了，这种情况不为少数，如果你用单引号测试，是测不到注入点的，所以进一步的判断是有必要的。</p>
</blockquote>
<p>此时一个经典的方法是<strong>借助 and 和 or 来判断：</strong></p>
<ul>
<li>
<p>数字型：当输入的参数 <strong>x</strong> 为<strong>整型</strong>时，通常 php 文件中 Sql 语句类型大致如下： <code>select * from &lt;表名&gt; where id = x</code> 。 这种类型可以先用 <code>and 1=1</code> 和 <code>and 1=2</code> 来做尝试：</p>
<p><em>实例：</em></p>
<blockquote>
<p>① <code>http://www.mytest.com/showdetail.asp?id=49</code><br>
② <code>http://www.mytest.com/showdetail.asp?id=49 and 1=1</code><br>
③ <code>http://www.mytest.com/showdetail.asp?id=49 and 1=2</code></p>
<p><strong>可以注入的表现：</strong><br>
① 正常显示<br>
② 正常显示，内容基本与 ① 相同。</p>
<p>后台执行 Sql 语句大致为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> &lt;表名&gt; <span class="keyword">where</span> <span class="keyword">id</span> = x <span class="keyword">and</span> <span class="number">1</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>没有语法错误且逻辑判断为正确，所以返回正常。</p>
<p>③ 提示 BOF 或 EOF（程序没做任何判断时）、或提示找不到记录（判断了 rs.eof 时）、或显示内容为空（程序加了 on error resume next）</p>
<p>后台执行 Sql 语句大致为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> &lt;表名&gt; <span class="keyword">where</span> <span class="keyword">id</span> = x <span class="keyword">and</span> <span class="number">1</span>=<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>没有语法错误但是逻辑判断为假，所以返回错误。</p>
<p><strong>不可以注入的表现：</strong></p>
<p>① 同样正常显示，② 和 ③ 一般都会有程序定义的错误提示，或提示类型转换时出错。</p>
</blockquote>
<p>或者我们也可以先把参数改为很大的数或负数，要让它查询不到数据，再在最后加上 or 1=1 就成功返回了数据，这是因为 1=1 为真，不管前面是不是假，数据都会返回。当 or 1=2 时，因为 1=2 为假，前后都为假，最终也是假，数据就不会返回了。</p>
</li>
<li>
<p>字符型：当输入的参数 <strong>x 为字符型</strong>时，通常 php 文件中 SQL 语句类型大致如下： <code>select * from &lt;表名&gt; where id = 'x'</code> 这种类型我们同样可以使用 <code>and '1'='1</code> 和 <code>and '1'='2</code>来判断：</p>
<blockquote>
<p>① URL 地址中输入 <code>http://xxx/abc.php?id= x' and '1'='1</code> 页面运行正常，继续进行下一步。</p>
<p>② URL 地址中输入 <code>http://xxx/abc.php?id= x' and '1'='2</code> 页面运行错误，则说明此 Sql 注入为字符型注入。</p>
</blockquote>
</li>
<li>
<p>除此之外还有搜索型注入，等做到相关题目再行补充。</p>
</li>
</ul>
<h2 id="漏洞利用">漏洞利用</h2>
<h3 id="数据库类型判断">数据库类型判断</h3>
<h4 id="通过网站脚本类型判断">通过网站脚本类型判断</h4>
<ul>
<li>PHP -&gt; Oracle、MySQL</li>
<li>JSP -&gt; Oracle、MySQL</li>
<li>ASP/.NET -&gt; SQL Server</li>
</ul>
<h4 id="通过错误信息判断">通过错误信息判断</h4>
<ul>
<li>MySQL -&gt; <code>error:You have an error in your SQL syntax; check themanual that corresponds to your MySQL server version</code></li>
<li>Oracle -&gt; <code>Microsoft OLE DB Provider for ODBC Drivers 错误</code></li>
</ul>
<h4 id="通过数字函数判断">通过数字函数判断</h4>
<ul>
<li>SQL Server -&gt; <code>@@pack_received、@@rowcount</code></li>
<li>MySQL -&gt; <code>connection_id()、last_insert_id() 、 row_count()</code></li>
<li>Oracle -&gt; <code>BITAND(1,1)</code></li>
<li>PostgreSQL -&gt; <code>select EXTRACT(DOW FROMNOW())</code></li>
</ul>
<h3 id="通过-UNION-语句提取数据">通过 UNION 语句提取数据</h3>
<blockquote>
<p>UNION 操作符可以合并两条或多条 SELECT 语句的查询结果，基本语法如下：<br>
<code>select column1 column2 from table1 UNION select column1 column2 from table2</code></p>
</blockquote>
<p><strong>使用 UNION 语句需要满足的条件：</strong> 前后两个查询的列数及对应列的数据类型必须相等。</p>
<p><em>一般过程为：</em></p>
<h4 id="获得列数">获得列数</h4>
<p>使用 <code>order by</code> 语句。最大且不报错的数值即为列数。</p>
<h4 id="获得回显点">获得回显点</h4>
<p>使用 <code>union select</code> 语句，查看回显点。</p>
<p><em>使用例：</em> <code>?id=-1' union select 1,2,3 %23</code></p>
<blockquote>
<p>说明：</p>
<p>先查询一个<strong>不存在的参数</strong>，本应该返回空的；<br>
但是使用 UNION 查询，会输出后面的查询；<br>
用<strong>数字去占位</strong>，所以能看到的数字就是回显点。</p>
</blockquote>
<h4 id="猜解数据库">猜解数据库</h4>
<ul>
<li>
<p>数据库版本信息：</p>
<p><code>?id=' union select 1, version(), 3 %23</code></p>
</li>
<li>
<p>当前数据库和用户：</p>
<p><code>?id=' union select 1, database(), user() %23</code></p>
</li>
<li>
<p>所有数据库：</p>
<p><code>?id=' union select 1, (select group_concat(schema_name) from information_schema.schemata), 3 %23</code></p>
</li>
<li>
<p>表名：</p>
<p><code>?id=' union select 1, (select group_concat(table_name) from information_schema.tables where table_schema='&lt;当前数据库名称&gt;'), 3 %23</code></p>
</li>
<li>
<p>列名：</p>
<p><code>?id=' union select 1, (select group_concat(column_name) from information_schema.columns where table_schema='&lt;当前数据库名称&gt;' and table_name='&lt;当前表名&gt;'), 3 %23</code></p>
</li>
<li>
<p>字段值 ( 其中 separator 可选 ) ：</p>
<p><code>?id=' union select 1,(select group_concat(&lt;查询到的列名&gt; separator ;) from &lt;当前表名&gt;), 3 %23</code></p>
</li>
</ul>
<h4 id="获取哈希口令">获取哈希口令</h4>
<blockquote>
<p>哈希口令是通过使用 PASSWORD() 函数计算的，具体算法取决于 MySQL 安装的版本。<br>
<code>select password('admin')</code><br>
也可以通过在线解密网站进行解密。如 <a href="http://www.cmd5.com/" target="_blank" rel="noopener">CMD5</a></p>
</blockquote>
<h4 id="写入-Webshell">写入 Webshell</h4>
<blockquote>
<p>需要得到网站的绝对路径，数据库管理系统有向服务器文件系统写文件的权限。<br>
<code>?id=1' union select &quot;&quot; into outfile &quot;D:\\XXX\\conn.php&quot;%23</code></p>
</blockquote>
<h3 id="盲注">盲注</h3>
<p>上述是用有回显注入举例说明 Sql 注入的基本过程的例子，盲注过程与此类似，只不过没有回显<br>
需要逐位尝试。</p>
<h4 id="时间盲注">时间盲注</h4>
<p><code>id=1 union select 1，if(SUBSTRING(user(),1,4)='root',sleep(5),1),3</code>（substring 函数的作用是将 user()从第一位字母到第四位字母截断。这段参数的注入逻辑是，user()的第一位到第四位如果为’root’，则页面等待 5 秒，否则结果为 1。）</p>
<p>脚本：待补充</p>
<h4 id="布尔盲注">布尔盲注</h4>
<p>脚本：待补充</p>
<h2 id="绕过方式">绕过方式</h2>
<h3 id="检测过滤的字符串">检测过滤的字符串</h3>
<p>可用异或注入检测过滤的字符串。异或即两个条件同真或同假即为假，两条件一真一假则为真。</p>
<p>样例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?id&#x3D;1&#39;^(length(&#39;and&#39;)!&#x3D;0)--+</span><br></pre></td></tr></table></figure>
<p>此样例可用来判断 and 是否被过滤。若满足异或条件则返回 id=0 对应的值，即被过滤。不满足异或条件则返回 id=1 对应的值，即未被过滤。也可以用<code>xor</code>来构造语句。</p>
<p>不过，有的时候需要使用 <code>=</code> 而不是 <code>!=</code> 来判断。例如，WAF 过滤了 or，那么 order 的 length 就为 3，虽然不等于 0，但是没有 order 的功能了。</p>
<h2 id="防御相关">防御相关</h2>
<p>目前还没什么概念，等以后再补充。</p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF中琐碎的姿势们</title>
    <url>/blog/2020/06/16/CTF%E4%B8%AD%E7%90%90%E7%A2%8E%E7%9A%84%E5%A7%BF%E5%8A%BF%E4%BB%AC/</url>
    <content><![CDATA[<p>记录CTF中的一些琐碎杂项备忘，方便查找。</p>
<a id="more"></a>
<h2 id="HTML">HTML</h2>
<h3 id="HTML中的特殊转义字符">HTML中的特殊转义字符</h3>
<table>
<thead>
<tr>
<th>字符</th>
<th>十进制</th>
<th>转义字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>&quot;</td>
<td><code>&amp;#34;</code></td>
<td><code>&amp;quot;</code></td>
</tr>
<tr>
<td>&amp;</td>
<td><code>&amp;#38;</code></td>
<td><code>&amp;amp;</code></td>
</tr>
<tr>
<td>&lt;</td>
<td><code>&amp;#60;</code></td>
<td><code>&amp;lt;</code></td>
</tr>
<tr>
<td>&gt;</td>
<td><code>&amp;#62;</code></td>
<td><code>&amp;gt;</code></td>
</tr>
<tr>
<td>不断开空格(non-breaking space)</td>
<td><code>&amp;#160;</code></td>
<td><code>&amp;nbsp;</code></td>
</tr>
<tr>
<td>|</td>
<td><code>&amp;#166;</code></td>
<td><code>&amp;brvbar;</code></td>
</tr>
</tbody>
</table>
<h2 id="Linux">Linux</h2>
<h3 id="vim">vim</h3>
<h3 id="swp-swo-…-文件">.swp/.swo/… 文件</h3>
<p>这些文件是vim创建的临时文件。一个文件在vim中打开之后会创建 .swp 文件。如果 .swp 文件已存在，则创建 .swo 文件，若 .swo 文件存在则创建 .swn 文件，以此类推。vim 关闭时这些文件将自动被删除，若vim崩溃或被杀死，则保留。有时可用作 CTF 中源码的来源。</p>
<p>例如：一个叫 <code>abc.php</code> 的文件会产生一个名为 <code>.abc.php.swp</code> 的临时文件。注意文件最前面有一个小点。</p>
<h2 id="PHP">PHP</h2>
<h3 id="PHP基础">PHP基础</h3>
<h4 id="的区别">-&gt; , =&gt; , :: 的区别</h4>
<p><code>-&gt;</code> 是插入式解引用的符号，用法与C语言相似。<code>=&gt;</code> 在数组中常常出现，用来连接键值对。<code>::</code> 与C语言中的 <code>.</code> 类似，用于调用类的内部成员，或类之间的相互调用。</p>
<h2 id="配置错误">配置错误</h2>
<h3 id="源码泄露">源码泄露</h3>
<h4 id="常见的网站源码备份文件后缀">常见的网站源码备份文件后缀</h4>
<ul>
<li>tar</li>
<li>tar.gz</li>
<li>zip</li>
<li>rar</li>
</ul>
<h4 id="常见的网站源码备份文件名">常见的网站源码备份文件名</h4>
<ul>
<li>web</li>
<li>website</li>
<li>backup</li>
<li>back</li>
<li>www</li>
<li>wwwroot</li>
<li>temp</li>
</ul>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF中的命令执行</title>
    <url>/blog/2020/06/16/CTF%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Linux相关笔记</title>
    <url>/blog/2020/06/16/Linux%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>PHP反序列化笔记</title>
    <url>/blog/2020/06/16/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Mysql基础补完</title>
    <url>/blog/2020/06/17/Mysql%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%AE%8C/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>前端三剑客笔记</title>
    <url>/blog/2020/06/16/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Python利用多线程和多进程编写脚本</title>
    <url>/blog/2020/06/16/Python%E5%88%A9%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>正则学习笔记</title>
    <url>/blog/2020/06/16/%E6%AD%A3%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>CTF中经常出现的正则，基础薄弱。突击学习下记点笔记。</p>
<a id="more"></a>
<h2 id="PHP正则">PHP正则</h2>
<p>PCRE库函数中，正则匹配模式使用分隔符与元字符组成。</p>
<h3 id="分隔符">分隔符</h3>
<p>分隔符可以是非数字、非反斜线、非空格的任意字符。经常使用的分隔符是正斜线(/)、hash符号(#) 以及取反符号(~)，例如：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">/foo bar/</span><br><span class="line"><span class="comment">#^[^0-9]$#</span></span><br><span class="line">~php~</span><br></pre></td></tr></table></figure>
<p>如果模式中包含分隔符，则分隔符需要使用反斜杠（\）进行转义。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">/http:\/\<span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>如果模式中包含较多的分割字符，建议更换其他的字符作为分隔符，也可以采用preg_quote进行转义。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$p = <span class="string">'http://'</span>;</span><br><span class="line">$p = <span class="string">'/'</span>.preg_quote($p, <span class="string">'/'</span>).<span class="string">'/'</span>;</span><br><span class="line"><span class="keyword">echo</span> $p;</span><br></pre></td></tr></table></figure>
<p>除了上面提到的分隔符，也可以使用括号样式的分隔符，左括号和右括号分别作为开始和结束 分隔符。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&#123;this is a pattern&#125;</span><br></pre></td></tr></table></figure>
<p>分隔符后面可以使用模式修饰符（i，m，s，x等）。例如使用 i 修饰符可以忽略大小写匹配：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$str = <span class="string">"Http://www.imooc.com/"</span>;</span><br><span class="line"><span class="keyword">if</span> (preg_match(<span class="string">'/http/i'</span>, $str)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'匹配成功'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="元字符">元字符</h3>
<p>一些字符被赋予 特殊的涵义，使其不再单纯的代表自己，模式中的这种有特殊涵义的编码字符 称为 <em>元字符</em>。</p>
<p>共有两种不同的元字符：一种是可以在模式中方括号外任何地方使用的，另外一种 是需要在方括号内使用的。</p>
<p><strong>在方括号外使用的元字符如下：</strong></p>
<ul>
<li>
<p>**</p>
<p>一般用于转义字符</p>
</li>
<li>
<p><em>^</em></p>
<p>断言目标的开始位置(或在多行模式下是行首)</p>
</li>
<li>
<p><em>$</em></p>
<p>断言目标的结束位置(或在多行模式下是行尾)</p>
</li>
<li>
<p><em>.</em></p>
<p>匹配除换行符外的任何字符(默认)</p>
</li>
<li>
<p><em>[</em></p>
<p>开始字符类定义</p>
</li>
<li>
<p><em>]</em></p>
<p>结束字符类定义</p>
</li>
<li>
<p><em>|</em></p>
<p>开始一个可选分支</p>
</li>
<li>
<p><em>(</em></p>
<p>子组的开始标记</p>
</li>
<li>
<p><em>)</em></p>
<p>子组的结束标记</p>
</li>
<li>
<p><em>?</em></p>
<p>作为量词，表示 0 次或 1 次匹配。位于量词后面用于改变量词的贪婪特性。 (查阅<a href="https://www.php.net/manual/zh/regexp.reference.repetition.php" target="_blank" rel="noopener">量词</a>)</p>
</li>
<li>
<p><em>*</em></p>
<p>量词，0 次或多次匹配</p>
</li>
<li>
<p><em>+</em></p>
<p>量词，1 次或多次匹配</p>
</li>
<li>
<p><em>{</em></p>
<p>自定义量词开始标记</p>
</li>
<li>
<p><em>}</em></p>
<p>自定义量词结束标记</p>
</li>
</ul>
<p><strong>模式中方括号内的部分称为“字符类”。 在一个字符类中仅有以下可用元字符：</strong></p>
<ul>
<li>
<p>**</p>
<p>转义字符</p>
</li>
<li>
<p><em>^</em></p>
<p>仅在作为第一个字符(方括号内)时，表明字符类取反</p>
</li>
<li>
<p><em>-</em></p>
<p>标记字符范围</p>
</li>
</ul>
<h3 id="转义序列">转义序列</h3>
<p><em>\n</em></p>
<p>换行 (十六进制 0A)</p>
<p><em>\r</em></p>
<p>回车 (十六进制 0D)</p>
<p><em>\t</em></p>
<p>水平制表符 (十六进制 09)</p>
<p><em>\xhh</em></p>
<p>hh十六进制编码的字符，详细查看<a href="https://www.php.net/manual/zh/regexp.reference.unicode.php" target="_blank" rel="noopener">unicode properties</a> 属性</p>
<p><em>\ddd</em></p>
<p>ddd八进制编码的字符，或者后向引用</p>
<p><em>\040</em></p>
<p>空格的另外一种用法</p>
<p><em>\40</em></p>
<p>当提供了少于40个子组时也认为是空格。</p>
<p><em>\d</em></p>
<p>任意十进制数字</p>
<p><em>\D</em></p>
<p>任意非十进制数字</p>
<p><em>\h</em></p>
<p>任意水平空白字符(since PHP 5.2.4)</p>
<p><em>\H</em></p>
<p>任意非水平空白字符(since PHP 5.2.4)</p>
<p><em>\s</em></p>
<p>任意空白字符</p>
<p><em>\S</em></p>
<p>任意非空白字符</p>
<p><em>\v</em></p>
<p>任意垂直空白字符(since PHP 5.2.4)</p>
<p><em>\V</em></p>
<p>任意非垂直空白字符(since PHP 5.2.4)</p>
<p><em>\w</em></p>
<p>任意单词字符</p>
<p><em>\W</em></p>
<p>任意非单词字符</p>
<p><em>\b</em></p>
<p>单词边界</p>
<p><em>\B</em></p>
<p>非单词边界</p>
<p><em>\A</em></p>
<p>目标的开始位置(独立于多行模式)</p>
<p><em>\Z</em></p>
<p>目标的结束位置或结束处的换行符(独立于多行模式)</p>
<p><em>\z</em></p>
<p>目标的结束位置(独立于多行模式)</p>
<p><em>\G</em></p>
<p>在目标中首次匹配位置</p>
<h3 id="字符类">字符类</h3>
<p>方括号标记开始结束。一个按类而不是按顺序匹配的规则。如</p>
<p>[A-Z0-9]可以匹配A-Z或0-9之中的所有内容，而不是按顺序先匹配字母再匹配数字。</p>
<h3 id="可选路径">可选路径</h3>
<p>竖线用于分离模式中的可选路径。 比如模式<em>gilbert|Sullivan</em>匹配 ”gilbert” 或者 ”sullivan”。匹配的处理从左到右尝试每一个可选路径，并且使用第一个成功匹配的。</p>
<h3 id="修饰符">修饰符</h3>
<table>
<thead>
<tr>
<th><em>i</em></th>
<th>不区分大小写（ignore） for <a href="https://www.php.net/manual/zh/reference.pcre.pattern.modifiers.php" target="_blank" rel="noopener">PCRE_CASELESS</a></th>
</tr>
</thead>
<tbody>
<tr>
<td><em>m</em></td>
<td>多行匹配（more） for <a href="https://www.php.net/manual/zh/reference.pcre.pattern.modifiers.php" target="_blank" rel="noopener">PCRE_MULTILINE</a></td>
</tr>
<tr>
<td><em>s</em></td>
<td>句点使用时匹配包含换行符 for <a href="https://www.php.net/manual/zh/reference.pcre.pattern.modifiers.php" target="_blank" rel="noopener">PCRE_DOTALL</a></td>
</tr>
<tr>
<td><em>x</em></td>
<td>将模式中的空白忽略 for <a href="https://www.php.net/manual/zh/reference.pcre.pattern.modifiers.php" target="_blank" rel="noopener">PCRE_EXTENDED</a></td>
</tr>
<tr>
<td><em>U</em></td>
<td>只匹配最近的一个字符串;不重复匹配 for <a href="https://www.php.net/manual/zh/reference.pcre.pattern.modifiers.php" target="_blank" rel="noopener">PCRE_UNGREEDY</a></td>
</tr>
<tr>
<td><em>X</em></td>
<td>任意反斜线后接没有特殊含义的字符会导致一个错误 for <a href="https://www.php.net/manual/zh/reference.pcre.pattern.modifiers.php" target="_blank" rel="noopener">PCRE_EXTRA</a></td>
</tr>
<tr>
<td><em>J</em></td>
<td>允许子组重名 for <a href="https://www.php.net/manual/zh/reference.pcre.pattern.modifiers.php" target="_blank" rel="noopener">PCRE_INFO_JCHANGED</a></td>
</tr>
</tbody>
</table>
<p>e was <em>DEPRECATED</em> in PHP 5.5.0, and <em>REMOVED</em> as of PHP 7.0.0. 如果设置了这个被弃用的修饰符， <a href="https://www.php.net/manual/zh/function.preg-replace.php" target="_blank" rel="noopener">preg_replace()</a> 在进行了对替换字符串的 后向引用替换之后, 将替换后的字符串作为php 代码评估执行(eval 函数方式)，并使用执行结果 作为实际参与替换的字符串。单引号、双引号、反斜线(**)和 NULL 字符在 后向引用替换时会被用反斜线转义.详见php手册。</p>
<p><em>A</em> (<em>PCRE_ANCHORED</em>)  如果设置了这个修饰符，模式被强制为&quot;锚定&quot;模式，也就是说约束匹配使其仅从 目标字符串的开始位置搜索。这个效果同样可以使用适当的模式构造出来，并且 这也是 perl 种实现这种模式的唯一途径。</p>
<p><em>U</em> (<em>PCRE_UNGREEDY</em>)  这个修饰符逆转了量词的&quot;贪婪&quot;模式。 使量词默认为非贪婪的，通过量词后紧跟*?* 的方式可以使其成为贪婪的。这和 perl 是不兼容的。 它同样可以使用 <a href="https://www.php.net/manual/zh/regexp.reference.internal-options.php" target="_blank" rel="noopener">模式内修饰符设置</a> (<em>?U</em>)进行设置， 或者在量词后以问号标记其非贪婪(比如*.*?*)。</p>
<h3 id="子组">子组</h3>
<p>子组通过圆括号分隔界定，并且它们可以嵌套。 将一个模式中的一部分标记为子组(子模式)主要是来做两件事情：</p>
<ol>
<li>将可选分支局部化。比如，模式*cat(arcat|erpillar|)*匹配 ”cat”， “cataract”， “caterpillar” 中的一个，如果没有圆括号的话，它匹配的则是 ”cataract”， “erpillar” 以及空字符串。</li>
<li>将子组设定为捕获子组(向上面定义的)。当整个模式匹配后， 目标字符串中匹配子组的部分将会通过 <strong>pcre_exec()()</strong> 的 <em>ovector</em> 参数回传给调用者。 左括号从左至右出现的次序就是对应子组的下标(从 1 开始)， 可以通过这些下标数字来获取捕获子模式匹配结果。</li>
</ol>
<p>为了方便简写，如果需要在非捕获子组开始位置设置选项， 选项字母可以位于 ? 和 : 之间，比如：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">?i:saturday</span>|sunday)</span><br><span class="line">(<span class="name">?:</span>(<span class="name">?i</span>)saturday|sunday)</span><br></pre></td></tr></table></figure>
<h3 id="注释">注释</h3>
<p>字符序列(?#标记开始一个注释直到遇到一个右括号。不允许嵌套括号。 注释中的字符不会作为模式的一部分参与匹配。如：<code>/te(?# comments)st/</code></p>
<h3 id="递归模式">递归模式</h3>
<p>(?R) 套个娃。</p>
<h3 id="贪婪模式与懒惰模式">贪婪模式与懒惰模式</h3>
<p>正则表达式中每个元字符匹配一个字符，当使用+之后将会变的贪婪，它将匹配尽可能多的字符，但使用问号?字符时，它将尽可能少的匹配字符，既是懒惰模式。</p>
<ul>
<li>贪婪模式：在可匹配与可不匹配的时候，优先匹配<br>
//下面的\d表示匹配数字</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$p = <span class="string">'/\d+\-\d+/'</span>;</span><br><span class="line">$str = <span class="string">"我的电话是010-12345678"</span>;</span><br><span class="line">preg_match($p, $str, $match);</span><br><span class="line"><span class="keyword">echo</span> $match[<span class="number">0</span>]; <span class="comment">//结果为：010-12345678</span></span><br></pre></td></tr></table></figure>
<ul>
<li>懒惰模式：在可匹配与可不匹配的时候，优先不匹配</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$p = <span class="string">'/\d?\-\d?/'</span>;</span><br><span class="line">$str = <span class="string">"我的电话是010-12345678"</span>;</span><br><span class="line">preg_match($p, $str, $match);</span><br><span class="line"><span class="keyword">echo</span> $match[<span class="number">0</span>]; <span class="comment">//结果为：0-1</span></span><br></pre></td></tr></table></figure>
<p>当我们确切的知道所匹配的字符长度的时候，可以使用{}指定匹配字符数</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$p = <span class="string">'/\d&#123;3&#125;\-\d&#123;8&#125;/'</span>;</span><br><span class="line">$str = <span class="string">"我的电话是010-12345678"</span>;</span><br><span class="line">preg_match($p, $str, $match);</span><br><span class="line"><span class="keyword">echo</span> $match[<span class="number">0</span>]; <span class="comment">//结果为：010-12345678</span></span><br></pre></td></tr></table></figure>
<h3 id="使用正则进行匹配">使用正则进行匹配</h3>
<p>preg_match用来执行一个匹配，可以简单的用来判断模式是否匹配成功，或者取得一个匹配结果，他的返回值是匹配成功的次数0或者1，在匹配到1次以后就会停止搜索。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$subject = <span class="string">"abcdef"</span>;</span><br><span class="line">$pattern = <span class="string">'/def/'</span>;</span><br><span class="line">preg_match($pattern, $subject, $matches);</span><br><span class="line">print_r($matches); <span class="comment">//结果为：Array ( [0] =&gt; def )</span></span><br></pre></td></tr></table></figure>
<p>上面的代码简单的执行了一个匹配，简单的判断def是否能匹配成功，但是正则表达式的强大的地方是进行模式匹配，因此更多的时候，会使用模式：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$subject = <span class="string">"abcdef"</span>;</span><br><span class="line">$pattern = <span class="string">'/a(.*?)d/'</span>;</span><br><span class="line">preg_match($pattern, $subject, $matches);</span><br><span class="line">print_r($matches); <span class="comment">//结果为：Array ( [0] =&gt; abcd [1] =&gt; bc )</span></span><br></pre></td></tr></table></figure>
<h3 id="查找所有匹配结果">查找所有匹配结果</h3>
<p>preg_match只能匹配一次结果，但很多时候我们需要匹配所有的结果，preg_match_all可以循环获取一个列表的匹配结果数组。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$p</span> = <span class="string">"|&lt;[^&gt;]+&gt;(.*?)&lt;/[^&gt;]+&gt;|i"</span>;</span><br><span class="line"><span class="variable">$str</span> = <span class="string">"&lt;b&gt;example: &lt;/b&gt;&lt;div align=left&gt;this is a test&lt;/div&gt;"</span>;</span><br><span class="line">preg_match_all(<span class="variable">$p</span>, <span class="variable">$str</span>, <span class="variable">$matches</span>);</span><br><span class="line">print_r(<span class="variable">$matches</span>);</span><br></pre></td></tr></table></figure>
<p>可以使用preg_match_all匹配一个表格中的数据：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$p = "/<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>(.*?)<span class="tag">&lt;<span class="name">\</span>/<span class="attr">td</span>&gt;</span>\s*<span class="tag">&lt;<span class="name">td</span>&gt;</span>(.*?)<span class="tag">&lt;<span class="name">\</span>/<span class="attr">td</span>&gt;</span>\s*<span class="tag">&lt;<span class="name">\</span>/<span class="attr">tr</span>&gt;</span>/i";</span><br><span class="line">$str = "<span class="tag">&lt;<span class="name">table</span>&gt;</span> <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Eric<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>25<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>John<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>26<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span> <span class="tag">&lt;/<span class="name">table</span>&gt;</span>";</span><br><span class="line">preg_match_all($p, $str, $matches);</span><br><span class="line">print_r($matches);</span><br></pre></td></tr></table></figure>
<p>$matches结果排序为$matches[0]保存完整模式的所有匹配, $matches[1] 保存第一个子组的所有匹配，以此类推。</p>
<h3 id="正则表达式的搜索和替换">正则表达式的搜索和替换</h3>
<p>正则表达式的搜索与替换在某些方面具有重要用途，比如调整目标字符串的格式，改变目标字符串中匹配字符串的顺序等。</p>
<p>例如我们可以简单的调整字符串的日期格式：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$string = <span class="string">'April 15, 2014'</span>;</span><br><span class="line">$pattern = <span class="string">'/(\w+) (\d+), (\d+)/i'</span>;</span><br><span class="line">$replacement = <span class="string">'$3, $&#123;1&#125; $2'</span>;</span><br><span class="line"><span class="keyword">echo</span> preg_replace($pattern, $replacement, $string); <span class="comment">//结果为：2014, April 15</span></span><br></pre></td></tr></table></figure>
<p>其中${1}与$1的写法是等效的，表示第一个匹配的字串，$2代表第二个匹配的。</p>
<p>通过复杂的模式，我们可以更加精确的替换目标字符串的内容。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$patterns = <span class="keyword">array</span> (<span class="string">'/(19|20)(\d&#123;2&#125;)-(\d&#123;1,2&#125;)-(\d&#123;1,2&#125;)/'</span>,</span><br><span class="line">                   <span class="string">'/^\s*&#123;(\w+)&#125;\s*=/'</span>);</span><br><span class="line">$replace = <span class="keyword">array</span> (<span class="string">'\3/\4/\1\2'</span>, <span class="string">'$\1 ='</span>);<span class="comment">//\3等效于$3,\4等效于$4，依次类推</span></span><br><span class="line"><span class="keyword">echo</span> preg_replace($patterns, $replace, <span class="string">'&#123;startDate&#125; = 1999-5-27'</span>); <span class="comment">//结果为：$startDate = 5/27/1999</span></span><br></pre></td></tr></table></figure>
<p>//详细解释下结果：(19|20)表示取19或者20中任意一个数字，(\d{2})表示两个数字，(\d{1,2})表示1个或2个数字，(\d{1,2})表示1个或2个数字。^\s*{(\w+)\s*=}表示以任意空格开头的，并且包含在{}中的字符，并且以任意空格结尾的，最后有个=号的。<br>
用正则替换来去掉多余的空格与字符：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$str</span> = <span class="string">'one     two'</span>;</span><br><span class="line"><span class="variable">$str</span> = preg_replace(<span class="string">'/\s+/'</span>, <span class="string">' '</span>, <span class="variable">$str</span>);</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span>; // 结果改变为<span class="string">'one two'</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>网络安全</category>
        <category>开发</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>Tkinter学习笔记</title>
    <url>/blog/2020/06/16/Tkinter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>PHP相关姿势</title>
    <url>/blog/2020/06/16/PHP%E7%9B%B8%E5%85%B3%E5%A7%BF%E5%8A%BF/</url>
    <content><![CDATA[<p>整理 CTF 中 PHP 相关的利用姿势，不定期补充。</p>
<a id="more"></a>
<h2 id="弱类型相关姿势">弱类型相关姿势</h2>
<p>弱类型的语言对变量的数据类型没有限制，你可以在任何地时候将变量赋值给任意的其他类型的变量，同时变量也可以转换成任意地其他类型的数据。</p>
<h3 id="比较操作符">比较操作符</h3>
<h4 id="类型转换">类型转换</h4>
<p>弱等的比较中不需左右两边的类型相等，会经过转换变成相同的类型后比较，由此产生安全问题。如：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$a=<span class="keyword">NULL</span>;$b=<span class="keyword">FALSE</span>;  <span class="comment">//$a==$b</span></span><br><span class="line">$a=<span class="string">''</span>;$b=<span class="keyword">NULL</span>;  <span class="comment">//$a==$b</span></span><br></pre></td></tr></table></figure>
<p>还有，bool类型的true跟任意字符串可以弱类型相等。</p>
<p>以及类型转换的一些规则，如字符串转数字会从不满足转换规则的位置开始截断只取最前边的数字部分而不会报错等。（ 注：数字到字符串可以用strval()，字符串和数字可以用intval() ）</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> == <span class="string">'0'</span>		<span class="comment">//true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">'abcdefg'</span>	<span class="comment">//true</span></span><br><span class="line"><span class="number">0</span> === <span class="string">'abcdefg'</span>	<span class="comment">//false</span></span><br><span class="line"><span class="number">1</span> == <span class="string">'1abcdef'</span>	<span class="comment">//true</span></span><br><span class="line"><span class="string">"0e123456"</span>==<span class="string">"0e4456789"</span>   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h4 id="哈希比较">哈希比较</h4>
<h5 id="md5-弱等的绕过">md5 弱等的绕过</h5>
<p>md5(‘240610708’) == md5(‘QNKCDZO’) (0exxxxxxx)</p>
<p>在进行比较运算时，如果遇到了0e\d+这种字符串，就会将这种字符串解析为科学计数法。所以上面例子中2个数的值都是0因而就相等了。如果不满足0e\d+这种模式就不会相等。</p>
<p>0e\d+ 的字符串整理：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">QNKCDZO</span><br><span class="line"><span class="number">0e830400451993494058024219903391</span></span><br><span class="line">s878926199a</span><br><span class="line"><span class="number">0e545993274517709034328855841020</span></span><br><span class="line">s155964671a</span><br><span class="line"><span class="number">0e342768416822451524974117254469</span></span><br><span class="line">s214587387a</span><br><span class="line"><span class="number">0e848240448830537924465865611904</span></span><br><span class="line">s214587387a</span><br><span class="line"><span class="number">0e848240448830537924465865611904</span></span><br><span class="line">s878926199a</span><br><span class="line"><span class="number">0e545993274517709034328855841020</span></span><br><span class="line">s1091221200a</span><br><span class="line"><span class="number">0e940624217856561557816327384675</span></span><br><span class="line">s1885207154a</span><br><span class="line"><span class="number">0e509367213418206700842008763514</span></span><br></pre></td></tr></table></figure>
<p>强等的绕过方法放在后文的 内置函数的参数松散性 一节中。</p>
<h5 id="绕过-md5-函数注入-MySQL">绕过 md5()函数注入 MySQL</h5>
<p><code>ffifdyop</code> 这个字符串被 md5 哈希了之后会变成 276f722736c95d99e921722cf9ed621c，这个字符串前几位刚好是 ‘ or ‘6（<code>'or'6\xc9]\x99\xe9!r,\xf9\xedb\x1c</code>），而 Mysql 刚好又会把 hex 转成 ascii 解释，因此拼接之后的形式是 <code>select * from 'admin' where password='' or '6xxxxx'</code></p>
<p>等价于 or 一个永真式，因此相当于万能密码，可以绕过 md5()函数。</p>
<p>或者 129581926211651571912466741651878684928，<br>
md5 值为 <code>\x06\xdaT0D\x9f\x8fo#\xdf\xc1'or'8</code> 也可行。</p>
<h4 id="十六进制转换">十六进制转换</h4>
<p>还存在一种十六进制余字符串进行比较运算时的问题。例子如下：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="string">"0x1e240"</span>==<span class="string">"123456"</span>		<span class="comment">//true</span></span><br><span class="line"><span class="string">"0x1e240"</span>==<span class="number">123456</span>		<span class="comment">//true</span></span><br><span class="line"><span class="string">"0x1e240"</span>==<span class="string">"1e240"</span>		<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>当其中的一个字符串是0x开头的时候，PHP会将此字符串解析成为十进制然后再进行比较，0x1e240解析成为十进制就是123456，所以与 int 类型和 string 类型的 123456 比较都是相等。攻防平台中的<strong>起名字真难</strong>就是考察的这个特性。</p>
<h4 id="json绕过">json绕过</h4>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'message'</span>])) &#123;</span><br><span class="line">    $message = json_decode($_POST[<span class="string">'message'</span>]);</span><br><span class="line">    $key =<span class="string">"*********"</span>;</span><br><span class="line">    <span class="keyword">if</span> ($message-&gt;key ==$key ) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"flag"</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"fail"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="keyword">echo</span> <span class="string">"~~~~"</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>输入一个json类型的字符串，json_decode函数解密成一个数组，判断数组中key的值是否等于$key的值，但$key的值我们不知道,这时我们构造一个和任意字符串返回为真的数组{“key”:true}。即可绕过。</p>
<p>payload: message={“key”,true}</p>
<h3 id="内置函数的参数松散性">内置函数的参数松散性</h3>
<h4 id="md5-强等的绕过">md5()  强等的绕过</h4>
<p>md5()中的需要是一个string类型的参数。如果md5 函数的参数是一个数组值，会导致函数返回 false。除了 md5 之外 sha1 函数也有这个特性。 例如传入为 <code>?a[]=1&amp;b[]=2</code></p>
<p>或者找到 md5 值相等的二进制数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2</span><br><span class="line"></span><br><span class="line">b&#x3D;%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2</span><br></pre></td></tr></table></figure>
<h4 id="strcmp">strcmp()</h4>
<p>strcmp()函数在PHP官方手册中的描述是<code>int strcmp ( string $str1 , string $str2 )</code>,需要给strcmp()传递2个string类型的参数。如果str1小于str2,返回-1，相等返回0，否则返回1。strcmp函数比较字符串的本质是将两个变量转换为ascii，然后进行减法运算，然后根据运算结果来决定返回值。<br>
如果传入给出strcmp()的参数是其它类型，可能产生其它不希望的结果。如：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$<span class="built_in">array</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">var_dump(strcmp($<span class="built_in">array</span>,<span class="string">'123'</span>)); <span class="comment">//null,在某种意义上null也就是相当于false，。</span></span><br></pre></td></tr></table></figure>
<h4 id="switch">switch()</h4>
<p>如果switch是数字类型的case的判断时，switch会将其中的参数转换为int类型。如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$i =<span class="string">"2abc"</span>;</span><br><span class="line"><span class="keyword">switch</span> ($i) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"i is less than 3 but not negative"</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"i is 3"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候程序输出的是<code>i is less than 3 but not negative</code>，是由于switch()函数将$i进行了类型转换，转换结果为2。</p>
<h4 id="in-array">in_array()</h4>
<p>在PHP手册中，in_array()函数的解释是<code>bool in_array ( mixed $needle , array $haystack [, bool $strict = FALSE ] )</code>,如果strict参数没有提供，那么in_array就会使用松散比较来判断$needle是否在$haystack中。当strince的值为true时，needls的类型和haystack中的类型会被严格比较。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">$<span class="built_in">array</span>=<span class="literal">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,'<span class="number">3</span>']</span>;</span><br><span class="line">var<span class="constructor">_dump(<span class="params">in_array</span>('<span class="params">abc</span>', $<span class="params">array</span>)</span>);  <span class="comment">//true</span></span><br><span class="line">var<span class="constructor">_dump(<span class="params">in_array</span>('1bc', $<span class="params">array</span>)</span>);	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>array_search()与in_array()也有一样的问题。</p>
<h2 id="PHP-Filter-相关姿势">PHP Filter 相关姿势</h2>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">php://<span class="built_in">filter</span>/<span class="built_in">read</span>=<span class="built_in">convert</span>.base64-encode/resource=</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP基础补完</title>
    <url>/blog/2020/06/16/PHP%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%AE%8C/</url>
    <content><![CDATA[<p>PHP基础太薄弱了。最近几天做个补完，记点笔记。</p>
<a id="more"></a>
<h2 id="PHP基础">PHP基础</h2>
<p>PHP 脚本可以放在文档中的任何位置，以<code>&lt;?php</code>开始，以 <code>?&gt;</code> 结束，每个代码行都必须以分号结束。</p>
<p><code>//</code> 是单行注释，<code>/**/</code>是多行注释。</p>
<h2 id="PHP变量">PHP变量</h2>
<h3 id="变量声明">变量声明</h3>
<p>变量以 $ 开始，大小写敏感。没有声明变量的命令，在声明变量在首次给变量赋值的同时完成。</p>
<h3 id="作用域">作用域</h3>
<p>变量的作用域是脚本中变量可被引用/使用的部分。</p>
<p>在所有函数外部定义的变量，拥有全局作用域。除了函数外，全局变量可以被脚本中的任何部分访问，<strong>要在一个函数中访问一个全局变量，需要使用 global 关键字</strong>。在 PHP 函数内部声明的变量是局部变量，仅能在函数内部访问。</p>
<p>**PHP中函数的花括号构成新的作用域。**if和for的花括号并不构成新的作用域。</p>
<p>PHP 有四种不同的变量作用域：</p>
<ul>
<li>local：局部变量</li>
<li>global：全局变量</li>
<li>static：静态变量</li>
<li>parameter：函数参数</li>
</ul>
<h4 id="global">global</h4>
<p>global 关键字用于<strong>函数内访问全局变量</strong>。要在函数内定义global变量需要先写global再声明。实例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$x=<span class="number">5</span>;</span><br><span class="line">$y=<span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">global</span> $x,$y,$a;</span><br><span class="line">    $y=$x+$y;</span><br><span class="line">    $a=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">myTest();</span><br><span class="line"><span class="keyword">echo</span> $y; <span class="comment">// 输出 15</span></span><br><span class="line"><span class="keyword">echo</span> $a; <span class="comment">// 输出 1</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>PHP 将所有全局变量存储在一个名为 $GLOBALS[<em>index</em>] 的数组中。 <em>index</em> 保存变量的名称。这个数组可以在函数内部访问，也可以直接用来更新全局变量。</p>
<p>上面的实例可以写成这样：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$x=<span class="number">5</span>;</span><br><span class="line">$y=<span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $GLOBALS[<span class="string">'y'</span>]=$GLOBALS[<span class="string">'x'</span>]+$GLOBALS[<span class="string">'y'</span>];</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">myTest();</span><br><span class="line"><span class="keyword">echo</span> $y;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>PHP的执行是以一个.php脚本为单位，在一个.php脚本的执行过程中，可以include和require其他PHP脚本进来执行。执行的.php脚本与include/require进来的脚本共享一个全局域(global scope)。global关键字无论在哪层，所引用的都是全局域的变量。</p>
<h4 id="Static">Static</h4>
<p>每次调用该函数时，该变量将会保留着函数前一次被调用时的值。该变量仍然是函数的局部变量，但不会像普通的局部变量一样因为函数完成而被删除。</p>
<h4 id="Parameter">Parameter</h4>
<p>参数是通过调用代码将值传递给函数的局部变量。参数是在参数列表中声明的，作为函数声明的一部分。实例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTest</span><span class="params">($x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> $x;</span><br><span class="line">&#125;</span><br><span class="line">myTest(<span class="number">5</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="预定义变量">预定义变量</h3>
<p>PHP 提供了大量的预定义变量。由于许多变量依赖于运行的服务器的版本和设置，及其它因素，所以并没有详细的说明文档。一些预定义变量在 PHP 以<a href="https://www.php.net/manual/zh/features.commandline.php" target="_blank" rel="noopener">命令行</a>形式运行时并不生效。有关这些变量的详细列表，请参阅<a href="https://www.php.net/manual/zh/reserved.variables.php" target="_blank" rel="noopener">预定义变量</a>一章。</p>
<p>如果有可用的 PHP 预定义变量那最好用，如<a href="https://www.php.net/manual/zh/language.variables.superglobals.php" target="_blank" rel="noopener">超全局数组</a>。</p>
<p>超级全局变量不能被用作函数或类方法中的<a href="https://www.php.net/manual/zh/language.variables.variable.php" target="_blank" rel="noopener">可变变量</a>。</p>
<ul>
<li><a href="https://www.php.net/manual/zh/language.variables.superglobals.php" target="_blank" rel="noopener">超全局变量</a> — 超全局变量是在全部作用域中始终可用的内置变量</li>
<li><a href="https://www.php.net/manual/zh/reserved.variables.globals.php" target="_blank" rel="noopener">$GLOBALS</a> — 引用全局作用域中可用的全部变量</li>
<li><a href="https://www.php.net/manual/zh/reserved.variables.server.php" target="_blank" rel="noopener">$_SERVER</a> — 服务器和执行环境信息</li>
<li><a href="https://www.php.net/manual/zh/reserved.variables.get.php" target="_blank" rel="noopener">$_GET</a> — HTTP GET 变量</li>
<li><a href="https://www.php.net/manual/zh/reserved.variables.post.php" target="_blank" rel="noopener">$_POST</a> — HTTP POST 变量</li>
<li><a href="https://www.php.net/manual/zh/reserved.variables.files.php" target="_blank" rel="noopener">$_FILES</a> — HTTP 文件上传变量</li>
<li><a href="https://www.php.net/manual/zh/reserved.variables.request.php" target="_blank" rel="noopener">$_REQUEST</a> — HTTP Request 变量</li>
<li><a href="https://www.php.net/manual/zh/reserved.variables.session.php" target="_blank" rel="noopener">$_SESSION</a> — Session 变量</li>
<li><a href="https://www.php.net/manual/zh/reserved.variables.environment.php" target="_blank" rel="noopener">$_ENV</a> — 环境变量</li>
<li><a href="https://www.php.net/manual/zh/reserved.variables.cookies.php" target="_blank" rel="noopener">$_COOKIE</a> — HTTP Cookies</li>
<li><a href="https://www.php.net/manual/zh/reserved.variables.phperrormsg.php" target="_blank" rel="noopener">$php_errormsg</a> — 前一个错误信息</li>
<li><a href="https://www.php.net/manual/zh/reserved.variables.httprawpostdata.php" target="_blank" rel="noopener">$HTTP_RAW_POST_DATA</a> — 原生POST数据</li>
<li><a href="https://www.php.net/manual/zh/reserved.variables.httpresponseheader.php" target="_blank" rel="noopener">$http_response_header</a> — HTTP 响应头</li>
<li><a href="https://www.php.net/manual/zh/reserved.variables.argc.php" target="_blank" rel="noopener">$argc</a> — 传递给脚本的参数数目</li>
<li><a href="https://www.php.net/manual/zh/reserved.variables.argv.php" target="_blank" rel="noopener">$argv</a> — 传递给脚本的参数数组</li>
</ul>
<h3 id="可变变量">可变变量</h3>
<p>在 PHP 的函数和类的方法中，<a href="https://www.php.net/manual/zh/language.variables.superglobals.php" target="_blank" rel="noopener">超全局变量</a>不能用作可变变量。<em>$this</em> 变量也是一个特殊变量，不能被动态引用。</p>
<p>要将可变变量用于数组，必须解决一个模棱两可的问题。这就是当写下 $$a[1] 时，解析器需要知道是想要 $a[1] 作为一个变量呢，还是想要 $$a 作为一个变量并取出该变量中索引为 [1] 的值。解决此问题的语法是，对第一种情况用 ${$a[1]}，对第二种情况用 ${$a}[1]。</p>
<h3 id="PHP之外的变量">PHP之外的变量</h3>
<p>通常，PHP 不会改变传递给脚本中的变量名。然而应该注意到点（句号）不是 PHP 变量名中的合法字符。至于原因，看看：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$varname.ext;  <span class="comment">/* 非法变量名 */</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>这时，解析器看到是一个名为 $varname 的变量，后面跟着一个字符串连接运算符，后面跟着一个裸字符串（即没有加引号的字符串，且不匹配任何已知的健名或保留字）‘ext’。很明显这不是想要的结果。</p>
<p>出于此原因，要注意 PHP 将会自动将外部变量名中的点替换成下划线。</p>
<p>因为 PHP 会判断变量类型并在需要时进行转换（通常情况下），因此在某一时刻给定的变量是何种类型并不明显。PHP 包括几个函数可以判断变量的类型，例如：<a href="https://www.php.net/manual/zh/function.gettype.php" target="_blank" rel="noopener">gettype()</a>，<a href="https://www.php.net/manual/zh/function.is-array.php" target="_blank" rel="noopener">is_array()</a>，<a href="https://www.php.net/manual/zh/function.is-float.php" target="_blank" rel="noopener">is_float()</a>，<a href="https://www.php.net/manual/zh/function.is-int.php" target="_blank" rel="noopener">is_int()</a>，<a href="https://www.php.net/manual/zh/function.is-object.php" target="_blank" rel="noopener">is_object()</a> 和 <a href="https://www.php.net/manual/zh/function.is-string.php" target="_blank" rel="noopener">is_string()</a>。参见<a href="https://www.php.net/manual/zh/language.types.php" target="_blank" rel="noopener">类型</a>一章。</p>
<h2 id="输出语句">输出语句</h2>
<h3 id="echo和print">echo和print</h3>
<ul>
<li>echo - 可以输出一个或多个字符串</li>
<li>print - 只允许输出一个字符串，返回值总为 1</li>
</ul>
<p>**提示：**echo 输出的速度比 print 快， echo 没有返回值，print有返回值1。</p>
<h3 id="echo">echo</h3>
<p>使用的时候可以不用加括号，也可以加上括号： echo 或 echo()。输出的字符串可以带有html标签，多个串用逗号隔开。</p>
<p>实例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$txt1=<span class="string">"学习 PHP"</span>;</span><br><span class="line">$txt2=<span class="string">"RUNOOB.COM"</span>;</span><br><span class="line">$cars=<span class="keyword">array</span>(<span class="string">"Volvo"</span>,<span class="string">"BMW"</span>,<span class="string">"Toyota"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> $txt1;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"在 $txt2 学习 PHP "</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"我车的品牌是 &#123;$cars[0]&#125;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="print">print</h3>
<p>可以使用括号，也可以不使用括号： print 或 print()。使用与echo基本相同。</p>
<h2 id="数据类型">数据类型</h2>
<h3 id="String">String</h3>
<p>放在单引号双引号中均可。</p>
<p>单引号除了单引号本身和反斜线以外其它均不转义。</p>
<p>当字符串用双引号或 heredoc 结构定义时，其中的<a href="https://www.php.net/manual/zh/language.variables.php" target="_blank" rel="noopener">变量</a>将会被解析。</p>
<p>PHP 的字符串在内部是字节组成的数组。因此用花括号访问或修改字符串对多字节字符集很不安全。</p>
<h4 id="heredoc">heredoc</h4>
<p><em>&lt;&lt;&lt;xxx</em>。</p>
<p>要注意的是结束标识符这行除了<em>可能</em>有一个分号（<em>;</em>）外，绝对不能包含其它字符。这意味着标识符<em>不能缩进</em>，分号的前后也不能有任何空白或制表符。更重要的是结束标识符的前面必须是个被本地操作系统认可的换行，比如在 UNIX 和 Mac OS X 系统中是 <em>\n</em>，而结束定界符（可能其后有个分号）之后也必须紧跟一个换行。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $bar = <span class="string">&lt;&lt;&lt;EOT</span></span><br><span class="line"><span class="string">bar</span></span><br><span class="line">    EOT;  <span class="comment">//非法！！！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="nowdoc">nowdoc</h4>
<p><em>&lt;&lt;&lt;‘xxx’</em>。</p>
<p>与heredoc结构相似，但不对特殊字符转义。（&gt;php5.3.0）</p>
<h4 id="变量解析">变量解析</h4>
<ul>
<li>
<p>简单语法</p>
<p>遇 <code>$</code> 尝试解析。</p>
</li>
<li>
<p>复杂语法</p>
<p>花括号括起。里面可以写复杂的表达式。只有 <em>$</em> 紧挨着 <em>{</em> 时才会被识别。</p>
</li>
</ul>
<h4 id="存取和修改字符">存取和修改字符</h4>
<p>用方括号或花括号访问。</p>
<h3 id="Int">Int</h3>
<p>不能包含逗号和空格，无小数点，可正可负，可以是十进制， 十六进制（ 以 0x 为前缀）或八进制（前缀为 0）。</p>
<h3 id="Float">Float</h3>
<p>带小数的或是指数形式的。例如： 1.2，2.4e3，8E-5。</p>
<h3 id="Bool">Bool</h3>
<p>true或false。</p>
<h3 id="Array">Array</h3>
<p>有序映射。映射是一种把 <em>values</em> 关联到 <em>keys</em> 的类型。由于数组元素的值也可以是另一个数组，树形结构和多维数组也是允许的。</p>
<h4 id="定义数组">定义数组</h4>
<p>可以用 <a href="https://www.php.net/manual/zh/function.array.php" target="_blank" rel="noopener">array()</a> 语言结构来新建一个数组。它接受任意数量用逗号分隔的 *键（key） =&gt; 值（value）*对。</p>
<p>自 5.4 起可以使用短数组定义语法，用 <em>[]</em> 替代 <em>array()</em>。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$array = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">"foo"</span> =&gt; <span class="string">"bar"</span>,</span><br><span class="line">    <span class="string">"bar"</span> =&gt; <span class="string">"foo"</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自 PHP 5.4 起</span></span><br><span class="line">$array = [</span><br><span class="line">    <span class="string">"foo"</span> =&gt; <span class="string">"bar"</span>,</span><br><span class="line">    <span class="string">"bar"</span> =&gt; <span class="string">"foo"</span>,</span><br><span class="line">];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>key 可以是 <a href="https://www.php.net/manual/zh/language.types.integer.php" target="_blank" rel="noopener">integer</a> 或者 <a href="https://www.php.net/manual/zh/language.types.string.php" target="_blank" rel="noopener">string</a>。value 可以是任意类型。</p>
<ul>
<li>包含有合法整型值的字符串会被转换为整型。例如键名 <em>“8”</em> 实际会被储存为 <em>8</em>。但是 <em>“08”</em> 则不会强制转换，因为其不是一个合法的十进制数值。</li>
<li>浮点数也会被转换为整型，意味着其小数部分会被舍去。例如键名 <em>8.7</em> 实际会被储存为 <em>8</em>。</li>
<li>布尔值也会被转换成整型。即键名 <em>true</em> 实际会被储存为 <em>1</em> 而键名 <em>false</em> 会被储存为 <em>0</em>。</li>
<li><a href="https://www.php.net/manual/zh/language.types.null.php" target="_blank" rel="noopener">Null</a> 会被转换为空字符串，即键名 <em>null</em> 实际会被储存为 <em>“”</em>。</li>
<li>数组和对象<em>不能</em>被用为键名。坚持这么做会导致警告：<em>Illegal offset type</em>。</li>
</ul>
<p><strong>如果在数组定义中多个单元都使用了同一个键名，则只使用了最后一个，之前的都被覆盖了。</strong></p>
<p>PHP 数组可以同时含有 <a href="https://www.php.net/manual/zh/language.types.integer.php" target="_blank" rel="noopener">integer</a> 和 <a href="https://www.php.net/manual/zh/language.types.string.php" target="_blank" rel="noopener">string</a> 类型的键名，因为 PHP 实际并不区分索引数组和关联数组。</p>
<p>如果未指定key，PHP 将自动使用之前用过的最大 <a href="https://www.php.net/manual/zh/language.types.integer.php" target="_blank" rel="noopener">integer</a> 键名加上 1 作为新的键名，之前没用过integer键名的取key值为0（注意这里所使用的最大整数键名<em>不一定</em>当前就在数组中。它只要在上次数组重新生成索引后曾经存在过就行了。）：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$array = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">"foo"</span> =&gt; <span class="string">"bar"</span>,</span><br><span class="line">    <span class="string">"bar"</span> =&gt; <span class="string">"foo"</span>,</span><br><span class="line">    <span class="number">100</span>   =&gt; <span class="number">-100</span>,</span><br><span class="line">    <span class="number">-100</span>  =&gt; <span class="number">100</span>,</span><br><span class="line">);</span><br><span class="line">$array[] = <span class="string">"a"</span>;</span><br><span class="line">var_dump($array);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">array(5) &#123;</span></span><br><span class="line"><span class="comment">  ["foo"]=&gt;</span></span><br><span class="line"><span class="comment">  string(3) "bar"</span></span><br><span class="line"><span class="comment">  ["bar"]=&gt;</span></span><br><span class="line"><span class="comment">  string(3) "foo"</span></span><br><span class="line"><span class="comment">  [100]=&gt;</span></span><br><span class="line"><span class="comment">  int(-100)</span></span><br><span class="line"><span class="comment">  [-100]=&gt;</span></span><br><span class="line"><span class="comment">  int(100)</span></span><br><span class="line"><span class="comment">  [101]=&gt;</span></span><br><span class="line"><span class="comment">  string(1) "a"</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>还可以只对某些单元指定键名而对其它的空置：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$array = <span class="keyword">array</span>(</span><br><span class="line">         <span class="string">"a"</span>,</span><br><span class="line">         <span class="string">"b"</span>,</span><br><span class="line">    <span class="number">6</span> =&gt; <span class="string">"c"</span>,</span><br><span class="line">         <span class="string">"d"</span>,</span><br><span class="line">);</span><br><span class="line">var_dump($array);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">array(4) &#123;</span></span><br><span class="line"><span class="comment">  [0]=&gt;</span></span><br><span class="line"><span class="comment">  string(1) "a"</span></span><br><span class="line"><span class="comment">  [1]=&gt;</span></span><br><span class="line"><span class="comment">  string(1) "b"</span></span><br><span class="line"><span class="comment">  [6]=&gt;</span></span><br><span class="line"><span class="comment">  string(1) "c"</span></span><br><span class="line"><span class="comment">  [7]=&gt;</span></span><br><span class="line"><span class="comment">  string(1) "d"</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="访问数组单元">访问数组单元</h4>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$array = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">"foo"</span> =&gt; <span class="string">"bar"</span>,</span><br><span class="line">    <span class="number">42</span>    =&gt; <span class="number">24</span>,</span><br><span class="line">    <span class="string">"multi"</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line">         <span class="string">"dimensional"</span> =&gt; <span class="keyword">array</span>(</span><br><span class="line">             <span class="string">"array"</span> =&gt; <span class="string">"foo"</span></span><br><span class="line">         )</span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">var_dump($array[<span class="string">"foo"</span>]);</span><br><span class="line">var_dump($array[<span class="number">42</span>]);</span><br><span class="line">var_dump($array[<span class="string">"multi"</span>][<span class="string">"dimensional"</span>][<span class="string">"array"</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Note</strong>:</p>
<p>方括号和花括号可以互换使用来访问数组单元（例如 $array[42] 和 $array{42} 在上例中效果相同）。</p>
</blockquote>
<h4 id="新建、修改、删除值">新建、修改、删除值</h4>
<p>要修改某个值，通过其键名给该单元赋一个新值。要删除某键值对，对其调用 <a href="https://www.php.net/manual/zh/function.unset.php" target="_blank" rel="noopener">unset()</a> 函数。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$arr = <span class="keyword">array</span>(<span class="number">5</span> =&gt; <span class="number">1</span>, <span class="number">12</span> =&gt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">$arr[] = <span class="number">56</span>;    <span class="comment">// This is the same as $arr[13] = 56;</span></span><br><span class="line">                <span class="comment">// at this point of the script</span></span><br><span class="line"></span><br><span class="line">$arr[<span class="string">"x"</span>] = <span class="number">42</span>; <span class="comment">// This adds a new element to</span></span><br><span class="line">                <span class="comment">// the array with key "x"</span></span><br><span class="line">                </span><br><span class="line"><span class="keyword">unset</span>($arr[<span class="number">5</span>]); <span class="comment">// This removes the element from the array</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unset</span>($arr);    <span class="comment">// This deletes the whole array</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="数组解引用">数组解引用</h4>
<p>自 PHP 5.4 起可以用直接对函数或方法调用的结果进行数组解引用，在此之前只能通过一个临时变量。</p>
<p>自 PHP 5.5 起可以直接对一个数组原型进行数组解引用。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// on PHP 5.4</span></span><br><span class="line">$secondElement = getArray()[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// previously</span></span><br><span class="line">$tmp = getArray();</span><br><span class="line">$secondElement = $tmp[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">list</span>(, $secondElement) = getArray();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="数组实用函数">数组实用函数</h4>
<p><a href="https://www.php.net/manual/zh/function.unset.php" target="_blank" rel="noopener">unset()</a> 函数允许删除数组中的某个键。但要注意数组将<em>不会</em>重建索引。如果需要删除后重建索引，可以用 <a href="https://www.php.net/manual/zh/function.array-values.php" target="_blank" rel="noopener">array_values()</a> 函数。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a = <span class="keyword">array</span>(<span class="number">1</span> =&gt; <span class="string">'one'</span>, <span class="number">2</span> =&gt; <span class="string">'two'</span>, <span class="number">3</span> =&gt; <span class="string">'three'</span>);</span><br><span class="line"><span class="keyword">unset</span>($a[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">/* will produce an array that would have been defined as</span></span><br><span class="line"><span class="comment">   $a = array(1 =&gt; 'one', 3 =&gt; 'three');</span></span><br><span class="line"><span class="comment">   and NOT</span></span><br><span class="line"><span class="comment">   $a = array(1 =&gt; 'one', 2 =&gt;'three');</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">$b = array_values($a);</span><br><span class="line"><span class="comment">// Now $b is array(0 =&gt; 'one', 1 =&gt;'three')</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>此外，foreach函数专门用于数组。（简单遍历）</p>
<h4 id="注意">注意</h4>
<p>应该始终在用字符串表示的数组索引上加上引号。而键名为常量和变量的不需要加引号。</p>
<p>可用函数返回值做数组索引。也可用已知常量。</p>
<h4 id="转换为数组">转换为数组</h4>
<p>对于任意 <a href="https://www.php.net/manual/zh/language.types.integer.php" target="_blank" rel="noopener">integer</a>，<a href="https://www.php.net/manual/zh/language.types.float.php" target="_blank" rel="noopener">float</a>，<a href="https://www.php.net/manual/zh/language.types.string.php" target="_blank" rel="noopener">string</a>，<a href="https://www.php.net/manual/zh/language.types.boolean.php" target="_blank" rel="noopener">boolean</a> 和 <a href="https://www.php.net/manual/zh/language.types.resource.php" target="_blank" rel="noopener">resource</a> 类型，如果将一个值转换为数组，将得到一个仅有一个元素的数组，其下标为 0，该元素即为此标量的值。换句话说，<em>(array)$scalarValue</em> 与 <em>array($scalarValue)</em> 完全一样。</p>
<p>如果一个 <a href="https://www.php.net/manual/zh/language.types.object.php" target="_blank" rel="noopener">object</a> 类型转换为 <a href="https://www.php.net/manual/zh/language.types.array.php" target="_blank" rel="noopener">array</a>，则结果为一个数组，其单元为该对象的属性。键名将为成员变量名，不过有几点例外：整数属性不可访问；私有变量前会加上类名作前缀；保护变量前会加上一个 ‘*’ 做前缀。这些前缀的前后都各有一个 NULL 字符。这会导致一些不可预知的行为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $A; <span class="comment">// This will become '\0A\0A'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $A; <span class="comment">// This will become '\0B\0A'</span></span><br><span class="line">    <span class="keyword">public</span> $AA; <span class="comment">// This will become 'AA'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump((<span class="keyword">array</span>) <span class="keyword">new</span> B());</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="比较">比较</h4>
<p>array_diff()，数组运算符。</p>
<h3 id="Object">Object</h3>
<h4 id="初始化">初始化</h4>
<p>new 语句。</p>
<h4 id="转换为对象">转换为对象</h4>
<p>如果其它任何类型的值被转换成对象，将会创建一个内置类 <em>stdClass</em> 的实例。如果该值为 <strong><code>NULL</code></strong>，则新的实例为空。 <a href="https://www.php.net/manual/zh/language.types.array.php" target="_blank" rel="noopener">array</a> 转换成 <a href="https://www.php.net/manual/zh/language.types.object.php" target="_blank" rel="noopener">object</a> 将使键名成为属性名并具有相对应的值。注意：在这个例子里， 使用 PHP 7.2.0 之前的版本，数字键只能通过迭代访问。对于其他值，会包含进成员变量名 <em>scalar</em>。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$obj = (object) <span class="string">'ciao'</span>;</span><br><span class="line"><span class="keyword">echo</span> $obj-&gt;scalar;  <span class="comment">// outputs 'ciao'</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Resource">Resource</h3>
<p><code>get_resource_type</code> 返回资源类型。例如：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$c = mysql_connect();</span><br><span class="line"><span class="keyword">echo</span> get_resource_type($c).<span class="string">"\n"</span>;</span><br><span class="line"><span class="comment">// 打印：mysql link</span></span><br><span class="line"></span><br><span class="line">$fp = fopen(<span class="string">"foo"</span>,<span class="string">"w"</span>);</span><br><span class="line"><span class="keyword">echo</span> get_resource_type($fp).<span class="string">"\n"</span>;</span><br><span class="line"><span class="comment">// 打印：file</span></span><br><span class="line"></span><br><span class="line">$doc = new_xmldoc(<span class="string">"1.0"</span>);</span><br><span class="line"><span class="keyword">echo</span> get_resource_type($doc-&gt;doc).<span class="string">"\n"</span>;</span><br><span class="line"><span class="comment">// 打印：domxml document</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Callback-Callable">Callback/Callable</h3>
<p>自 PHP 5.4 起可用 <a href="https://www.php.net/manual/zh/language.types.callable.php" target="_blank" rel="noopener">callable</a> 类型指定回调类型 callback。</p>
<h3 id="NULL">NULL</h3>
<p>NULL 值表示变量没有值。NULL 是数据类型为 NULL 的值。</p>
<h3 id="伪类型与变量">伪类型与变量</h3>
<h4 id="mixed">mixed</h4>
<p>一个参数可以接受多种不同的（但不一定是所有的）类型。</p>
<h4 id="number">number</h4>
<p>可以是 <a href="https://www.php.net/manual/zh/language.types.integer.php" target="_blank" rel="noopener">integer</a> 或者 <a href="https://www.php.net/manual/zh/language.types.float.php" target="_blank" rel="noopener">float</a>。</p>
<h4 id="callback">callback</h4>
<p>在 PHP 5.4 引入 <a href="https://www.php.net/manual/zh/language.types.callable.php" target="_blank" rel="noopener">callable</a> 类型之前使用 了 <a href="https://www.php.net/manual/zh/language.pseudo-types.php#language.types.callback" target="_blank" rel="noopener">callback</a> 伪类型。二者含义完全相同。</p>
<h4 id="array-object">array|object</h4>
<p>既可以是 <a href="https://www.php.net/manual/zh/language.types.array.php" target="_blank" rel="noopener">array</a> 也可以是 <a href="https://www.php.net/manual/zh/language.types.object.php" target="_blank" rel="noopener">object</a>。</p>
<h4 id="void">void</h4>
<p><em>void</em> 作为返回类型意味着函数的返回值是无用的。<em>void</em> 作为参数列表意味着函数不接受任何参数。</p>
<h4 id="…">…</h4>
<p>在函数原型中，<code>$...</code> 表示<em>等等</em>的意思。当一个函数可以接受任意个参数时使用此变量名。</p>
<h3 id="类型转换">类型转换</h3>
<h4 id="类型设置">类型设置</h4>
<p>settype设置变量类型。</p>
<p>settype ( <a href="https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="noopener">mixed</a> <code>&amp;$var</code> , string <code>$type</code> ) : bool</p>
<p>var是待转换变量。type是要转换的类型。返回值是成功与否。</p>
<p>实例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$foo = <span class="string">"5bar"</span>; <span class="comment">// string</span></span><br><span class="line">$bar = <span class="keyword">true</span>;   <span class="comment">// boolean</span></span><br><span class="line"></span><br><span class="line">settype($foo, <span class="string">"integer"</span>); <span class="comment">// $foo 现在是 5   (integer)</span></span><br><span class="line">settype($bar, <span class="string">"string"</span>);  <span class="comment">// $bar 现在是 "1" (string)</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="类型强制转换">类型强制转换</h4>
<p>在要转换的变量之前加上用括号括起来的目标类型。</p>
<p>允许的强制转换有：</p>
<ul>
<li>(int), (integer) - 转换为整形 <a href="https://www.php.net/manual/zh/language.types.integer.php" target="_blank" rel="noopener">integer</a></li>
<li>(bool), (boolean) - 转换为布尔类型 <a href="https://www.php.net/manual/zh/language.types.boolean.php" target="_blank" rel="noopener">boolean</a></li>
<li>(float), (double), (real) - 转换为浮点型 <a href="https://www.php.net/manual/zh/language.types.float.php" target="_blank" rel="noopener">float</a></li>
<li>(string) - 转换为字符串 <a href="https://www.php.net/manual/zh/language.types.string.php" target="_blank" rel="noopener">string</a></li>
<li>(array) - 转换为数组 <a href="https://www.php.net/manual/zh/language.types.array.php" target="_blank" rel="noopener">array</a></li>
<li>(object) - 转换为对象 <a href="https://www.php.net/manual/zh/language.types.object.php" target="_blank" rel="noopener">object</a></li>
<li>(unset) - 转换为 <a href="https://www.php.net/manual/zh/language.types.null.php" target="_blank" rel="noopener">NULL</a> (PHP 5)</li>
<li>(binary) 转换和 b 前缀转换支持为 PHP 5.2.1 新增。转换为二进制字符串。</li>
</ul>
<blockquote>
<p><strong>Note:</strong> 可以将变量放置在双引号中的方式来代替将变量转换成字符串。</p>
</blockquote>
<h2 id="运算符">运算符</h2>
<h3 id="运算符优先级">运算符优先级</h3>
<table>
<thead>
<tr>
<th style="text-align:left">结合方向</th>
<th style="text-align:left">运算符</th>
<th style="text-align:left">附加信息</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">无</td>
<td style="text-align:left">clone new</td>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.oop5.cloning.php" target="_blank" rel="noopener">clone</a> 和 <a href="https://www.php.net/manual/zh/language.oop5.basic.php#language.oop5.basic.new" target="_blank" rel="noopener">new</a></td>
</tr>
<tr>
<td style="text-align:left">右</td>
<td style="text-align:left">****</td>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.operators.arithmetic.php" target="_blank" rel="noopener">算术运算符</a></td>
</tr>
<tr>
<td style="text-align:left">右</td>
<td style="text-align:left"><em>++</em> <em>–</em> <em>~</em> <em>(int)</em> <em>(float)</em> <em>(string)</em> <em>(array)</em> <em>(object)</em> <em>(bool)</em> <em>@</em></td>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.types.php" target="_blank" rel="noopener">类型</a>、<a href="https://www.php.net/manual/zh/language.operators.increment.php" target="_blank" rel="noopener">递增／递减</a>、<a href="https://www.php.net/manual/zh/language.operators.errorcontrol.php" target="_blank" rel="noopener">错误控制</a></td>
</tr>
<tr>
<td style="text-align:left">无</td>
<td style="text-align:left"><em>instanceof</em></td>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.types.php" target="_blank" rel="noopener">类型</a></td>
</tr>
<tr>
<td style="text-align:left">右</td>
<td style="text-align:left"><em>!</em></td>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.operators.logical.php" target="_blank" rel="noopener">逻辑运算符</a></td>
</tr>
<tr>
<td style="text-align:left">左</td>
<td style="text-align:left">*** <em>/</em> <em>%</em></td>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.operators.arithmetic.php" target="_blank" rel="noopener">算术运算符</a></td>
</tr>
<tr>
<td style="text-align:left">左</td>
<td style="text-align:left"><em>+</em> <em>-</em> <em>.</em></td>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.operators.arithmetic.php" target="_blank" rel="noopener">算术运算符</a> 和 <a href="https://www.php.net/manual/zh/language.operators.string.php" target="_blank" rel="noopener">字符串运算符</a></td>
</tr>
<tr>
<td style="text-align:left">左</td>
<td style="text-align:left"><em>&lt;&lt;</em> <em>&gt;&gt;</em></td>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.operators.bitwise.php" target="_blank" rel="noopener">位运算符</a></td>
</tr>
<tr>
<td style="text-align:left">无</td>
<td style="text-align:left"><em>&lt;</em> <em>&lt;=</em> <em>&gt;</em> <em>&gt;=</em></td>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.operators.comparison.php" target="_blank" rel="noopener">比较运算符</a></td>
</tr>
<tr>
<td style="text-align:left">无</td>
<td style="text-align:left"><em>==</em> <em>!=</em> <em>===</em> <em>!==</em> <em>&lt;&gt;</em> <em>&lt;=&gt;</em></td>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.operators.comparison.php" target="_blank" rel="noopener">比较运算符</a></td>
</tr>
<tr>
<td style="text-align:left">左</td>
<td style="text-align:left"><em>&amp;</em></td>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.operators.bitwise.php" target="_blank" rel="noopener">位运算符</a> 和 <a href="https://www.php.net/manual/zh/language.references.php" target="_blank" rel="noopener">引用</a></td>
</tr>
<tr>
<td style="text-align:left">左</td>
<td style="text-align:left"><em>^</em></td>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.operators.bitwise.php" target="_blank" rel="noopener">位运算符</a></td>
</tr>
<tr>
<td style="text-align:left">左</td>
<td style="text-align:left"><em>|</em></td>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.operators.bitwise.php" target="_blank" rel="noopener">位运算符</a></td>
</tr>
<tr>
<td style="text-align:left">左</td>
<td style="text-align:left"><em>&amp;&amp;</em></td>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.operators.logical.php" target="_blank" rel="noopener">逻辑运算符</a></td>
</tr>
<tr>
<td style="text-align:left">左</td>
<td style="text-align:left"><em>||</em></td>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.operators.logical.php" target="_blank" rel="noopener">逻辑运算符</a></td>
</tr>
<tr>
<td style="text-align:left">右</td>
<td style="text-align:left"><em>??</em></td>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.operators.comparison.php#language.operators.comparison.coalesce" target="_blank" rel="noopener">null 合并运算符</a></td>
</tr>
<tr>
<td style="text-align:left">左</td>
<td style="text-align:left"><em>? :</em></td>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.operators.comparison.php#language.operators.comparison.ternary" target="_blank" rel="noopener">三元运算符</a></td>
</tr>
<tr>
<td style="text-align:left">右</td>
<td style="text-align:left"><em>=</em> <em>+=</em> <em>-=</em> *<em>=</em> **<em>=</em> <em>/=</em> <em>.=</em> <em>%=</em> <em>&amp;=</em> <em>|=</em> <em>^=</em> <em>&lt;&lt;=</em> <em>&gt;&gt;=</em></td>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.operators.assignment.php" target="_blank" rel="noopener">赋值运算符</a></td>
</tr>
<tr>
<td style="text-align:left">右</td>
<td style="text-align:left"><em>yield from</em></td>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.generators.syntax.php#control-structures.yield.from" target="_blank" rel="noopener">yield from</a></td>
</tr>
<tr>
<td style="text-align:left">右</td>
<td style="text-align:left"><em>yield</em></td>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.generators.syntax.php#control-structures.yield" target="_blank" rel="noopener">yield</a></td>
</tr>
<tr>
<td style="text-align:left">左</td>
<td style="text-align:left"><em>and</em></td>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.operators.logical.php" target="_blank" rel="noopener">逻辑运算符</a></td>
</tr>
<tr>
<td style="text-align:left">左</td>
<td style="text-align:left"><em>xor</em></td>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.operators.logical.php" target="_blank" rel="noopener">逻辑运算符</a></td>
</tr>
<tr>
<td style="text-align:left">左</td>
<td style="text-align:left"><em>or</em></td>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.operators.logical.php" target="_blank" rel="noopener">逻辑运算符</a></td>
</tr>
</tbody>
</table>
<h3 id="比较运算">比较运算</h3>
<p>注意 <code>==</code> 和 <code>===</code> 的区别。</p>
<p>特别注意的是，$a &lt;&gt; $b 与 $a != $b 表示相同的意思。$a &lt;=&gt; $b是结合比较运算符，当$a小于、等于、大于$b时分别返回一个小于、等于、大于0的<a href="https://www.php.net/manual/zh/language.types.integer.php" target="_blank" rel="noopener">integer</a> 值。 PHP7开始提供。</p>
<p><strong>多类型比较（按顺序）</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">运算数 1 类型</th>
<th style="text-align:left">运算数 2 类型</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.types.null.php" target="_blank" rel="noopener">null</a> 或 <a href="https://www.php.net/manual/zh/language.types.string.php" target="_blank" rel="noopener">string</a></td>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.types.string.php" target="_blank" rel="noopener">string</a></td>
<td style="text-align:left">将 <strong><code>NULL</code></strong> 转换为 “”，进行数字或词汇比较</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.types.boolean.php" target="_blank" rel="noopener">bool</a> 或 <a href="https://www.php.net/manual/zh/language.types.null.php" target="_blank" rel="noopener">null</a></td>
<td style="text-align:left">任何其它类型</td>
<td style="text-align:left">转换为 <a href="https://www.php.net/manual/zh/language.types.boolean.php" target="_blank" rel="noopener">bool</a>，<strong><code>FALSE</code></strong> &lt; <strong><code>TRUE</code></strong></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.types.object.php" target="_blank" rel="noopener">object</a></td>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.types.object.php" target="_blank" rel="noopener">object</a></td>
<td style="text-align:left">内置类可以定义自己的比较，不同类不能比较，相同类和数组同样方式比较属性（PHP 4 中），PHP 5 有其自己的<a href="https://www.php.net/manual/zh/language.oop5.object-comparison.php" target="_blank" rel="noopener">说明</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.types.string.php" target="_blank" rel="noopener">string</a>，<a href="https://www.php.net/manual/zh/language.types.resource.php" target="_blank" rel="noopener">resource</a> 或 <a href="https://www.php.net/manual/zh/language.pseudo-types.php#language.types.number" target="_blank" rel="noopener">number</a></td>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.types.string.php" target="_blank" rel="noopener">string</a>，<a href="https://www.php.net/manual/zh/language.types.resource.php" target="_blank" rel="noopener">resource</a> 或 <a href="https://www.php.net/manual/zh/language.pseudo-types.php#language.types.number" target="_blank" rel="noopener">number</a></td>
<td style="text-align:left">将字符串和资源转换成数字，按普通数学比较</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.types.array.php" target="_blank" rel="noopener">array</a></td>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.types.array.php" target="_blank" rel="noopener">array</a></td>
<td style="text-align:left">具有较少成员的数组较小，如果运算数 1 中的键不存在于运算数 2 中则数组无法比较，否则挨个值比较（见下例）</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.types.object.php" target="_blank" rel="noopener">object</a></td>
<td style="text-align:left">任何其它类型</td>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.types.object.php" target="_blank" rel="noopener">object</a> 总是更大</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.types.array.php" target="_blank" rel="noopener">array</a></td>
<td style="text-align:left">任何其它类型</td>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.types.array.php" target="_blank" rel="noopener">array</a> 总是更大</td>
</tr>
</tbody>
</table>
<p>注意！由于由于浮点数 <a href="https://www.php.net/manual/zh/language.types.float.php" target="_blank" rel="noopener">float</a> 的内部表达方式，不应比较两个浮点数<a href="https://www.php.net/manual/zh/language.types.float.php" target="_blank" rel="noopener">float</a>是否相等。更多信息参见 <a href="https://www.php.net/manual/zh/language.types.float.php" target="_blank" rel="noopener">float</a>。</p>
<h3 id="三目运算">三目运算</h3>
<p>表达式 <em>(expr1) ? (expr2) : (expr3)</em> 在 expr1 求值为 <strong><code>TRUE</code></strong> 时的值为 expr2，在 expr1 求值为 <strong><code>FALSE</code></strong> 时的值为 expr3。</p>
<p>自 PHP 5.3 起，可以省略三元运算符中间那部分。表达式 <em>expr1 ?: expr3</em> 在 expr1 求值为 <strong><code>TRUE</code></strong> 时返回 expr1，否则返回 expr3。</p>
<p>注意三元运算符是个语句，因此其求值不是变量，而是语句的结果。在一个通过引用返回的函数中语句 <em>return $var == 42 ? $a : $b;</em> 将不起作用，以后的 PHP 版本会为此发出一条警告。</p>
<h3 id="NULL合并运算">NULL合并运算</h3>
<p>当 expr1 为 <strong><code>NULL</code></strong>，表达式 <em>(expr1) ?? (expr2)</em> 等同于 expr2，否则为 expr1。</p>
<p>尤其要注意，当不存在左侧的值时，此运算符也和 <a href="https://www.php.net/manual/zh/function.isset.php" target="_blank" rel="noopener">isset()</a> 一样不会产生警告。 对于 array 键尤其有用。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// NULL 合并运算符的例子</span></span><br><span class="line">$action = $_POST[<span class="string">'action'</span>] ?? <span class="string">'default'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上例子等同于于以下 if/else 语句</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'action'</span>])) &#123;</span><br><span class="line">    $action = $_POST[<span class="string">'action'</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $action = <span class="string">'default'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意NULL 合并运算符是一个表达式，产生的也是表达式结果，而不是变量。在返回引用的函数里就无法使用这样的语句：<em>return $foo ?? $bar;</em>，还会提示警告。</p>
<p>NULL 合并运算符支持简单的嵌套：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$foo = <span class="keyword">null</span>;</span><br><span class="line">$bar = <span class="keyword">null</span>;</span><br><span class="line">$baz = <span class="number">1</span>;</span><br><span class="line">$qux = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $foo ?? $bar ?? $baz ?? $qux; <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="算数运算">算数运算</h3>
<p>除了加减乘除取模外还有：取反：<code>-$x</code> ，并置：<code>$a.$b</code>。</p>
<p>取反是取相反数，并置是连接两个字符串。</p>
<p>取反会先将待取反的变量转换为数值的形式。</p>
<h3 id="赋值运算">赋值运算</h3>
<p>没什么好说的。注意 $a .= $b 和 $a = $a . $b 表示的意思相同。</p>
<h3 id="递增递减">递增递减</h3>
<p>x++, ++x, x–, --x。</p>
<h3 id="逻辑运算">逻辑运算</h3>
<p>and与 / or或  /xor异或 / &amp;&amp;与 / ||或 / !非。</p>
<h3 id="位运算">位运算</h3>
<table>
<thead>
<tr>
<th style="text-align:left">例子</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong><code>$a &amp; $b</code></strong></td>
<td style="text-align:left">And（按位与）</td>
<td style="text-align:left">将把 $a 和 $b 中都为 1 的位设为 1。</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>$a | $b</code></strong></td>
<td style="text-align:left">Or（按位或）</td>
<td style="text-align:left">将把 $a 和 $b 中任何一个为 1 的位设为 1。</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>$a ^ $b</code></strong></td>
<td style="text-align:left">Xor（按位异或）</td>
<td style="text-align:left">将把 $a 和 $b 中一个为 1 另一个为 0 的位设为 1。</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>~ $a</code></strong></td>
<td style="text-align:left">Not（按位取反）</td>
<td style="text-align:left">将 $a 中为 0 的位设为 1，反之亦然。</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>$a &lt;&lt; $b</code></strong></td>
<td style="text-align:left">Shift left（左移）</td>
<td style="text-align:left">将 $a 中的位向左移动 $b 次（每一次移动都表示“乘以 2”）。</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>$a &gt;&gt; $b</code></strong></td>
<td style="text-align:left">Shift right（右移）</td>
<td style="text-align:left">将 $a 中的位向右移动 $b 次（每一次移动都表示“除以 2”）。</td>
</tr>
</tbody>
</table>
<p>位移在 PHP 中是数学运算。向任何方向（左右）移出去的位都被丢弃。左移时右侧以零填充，**符号位被移走意味着正负号不被保留。**右移时左侧以符号位填充，意味着正负号被保留。</p>
<p>若&amp;，/，^左右是字符串，则对ASCII做运算以后得到字符串结果，对于其它类型全部转成Integer，得到Integer结果。~操作同理。&lt;&lt;和&gt;&gt;左右两边都被当作 Integer 处理，String也不会转成ASCII。</p>
<p>PHP 的 ini 设定 error_reporting 使用了按位的值，提供了关闭某个位的实例。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">E_ALL ^ E_NOTICE</span><br><span class="line">具体运作方式是先取得 E_ALL 的值：</span><br><span class="line"><span class="number">00000000000000000111011111111111</span></span><br><span class="line">再取得 E_NOTICE 的值：</span><br><span class="line"><span class="number">00000000000000000000000000001000</span></span><br><span class="line">最后再用^得到两个值中都设定了（为 <span class="number">1</span>）的位：</span><br><span class="line"><span class="number">00000000000000000111011111110111</span></span><br></pre></td></tr></table></figure>
<h3 id="错误控制运算">错误控制运算</h3>
<p>@符号。当将其放置在一个 PHP 表达式之前，该表达式可能产生的任何错误信息都被忽略掉。</p>
<p>如果用 <a href="https://www.php.net/manual/zh/function.set-error-handler.php" target="_blank" rel="noopener">set_error_handler()</a> 设定了自定义的错误处理函数，仍然会被调用，但是此错误处理函数可以（并且也应该）调用 <a href="https://www.php.net/manual/zh/function.error-reporting.php" target="_blank" rel="noopener">error_reporting()</a>，而该函数在出错语句前有 @ 时将返回 0。</p>
<p>如果激活了 <a href="https://www.php.net/manual/zh/errorfunc.configuration.php#ini.track-errors" target="_blank" rel="noopener"><strong>track_errors</strong></a> 特性，表达式所产生的任何错误信息都被存放在变量 <a href="https://www.php.net/manual/zh/reserved.variables.phperrormsg.php" target="_blank" rel="noopener"><strong>$php_errormsg</strong></a> 中。此变量在每次出错时都会被覆盖，所以如果想用它的话就要尽早检查。</p>
<h3 id="执行运算">执行运算</h3>
<p>反引号（``）。PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回（即，可以赋给一个变量而不是简单地丢弃到标准输出）。使用反引号运算符的效果与函数 <a href="https://www.php.net/manual/zh/function.shell-exec.php" target="_blank" rel="noopener">shell_exec()</a> 相同。</p>
<p>注：exec命令，如果指定了command，它就会取代当前的shell而不是创建新的进程。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$output = `ls -al`;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;pre&gt;$output&lt;/pre&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>反引号运算符在激活了<a href="https://www.php.net/manual/zh/ini.sect.safe-mode.php#ini.safe-mode" target="_blank" rel="noopener">安全模式</a>或者关闭了 <a href="https://www.php.net/manual/zh/function.shell-exec.php" target="_blank" rel="noopener">shell_exec()</a> 时是无效的。</p>
<p>与其它某些语言不同，反引号不能在双引号字符串中使用。但是，由变量搭载则可以使用，如上例。</p>
<h3 id="数组运算">数组运算</h3>
<table>
<thead>
<tr>
<th style="text-align:left">例子</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$a + $b</td>
<td style="text-align:left">联合</td>
<td style="text-align:left">$a 和 $b 的联合。</td>
</tr>
<tr>
<td style="text-align:left">$a == $b</td>
<td style="text-align:left">相等</td>
<td style="text-align:left">如果 $a 和 $b 具有相同的键／值对则为 <strong><code>TRUE</code></strong>。</td>
</tr>
<tr>
<td style="text-align:left">$a === $b</td>
<td style="text-align:left">全等</td>
<td style="text-align:left">如果 $a 和 $b 具有相同的键／值对并且顺序和类型都相同则为 <strong><code>TRUE</code></strong>。</td>
</tr>
<tr>
<td style="text-align:left">$a != $b</td>
<td style="text-align:left">不等</td>
<td style="text-align:left">如果 $a 不等于 $b 则为 <strong><code>TRUE</code></strong>。</td>
</tr>
<tr>
<td style="text-align:left">$a &lt;&gt; $b</td>
<td style="text-align:left">不等</td>
<td style="text-align:left">如果 $a 不等于 $b 则为 <strong><code>TRUE</code></strong>。</td>
</tr>
<tr>
<td style="text-align:left">$a !== $b</td>
<td style="text-align:left">不全等</td>
<td style="text-align:left">如果 $a 不全等于 $b 则为 <strong><code>TRUE</code></strong>。</td>
</tr>
</tbody>
</table>
<p><em>+</em> 运算符把右边的数组元素附加到左边的数组后面，两个数组中都有的键名，则只用左边数组中的，右边的被忽略。</p>
<h3 id="类型运算">类型运算</h3>
<p><em>instanceof</em> 用于确定一个 PHP 变量是否属于某一类的实例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotMyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">$a = <span class="keyword">new</span> MyClass;</span><br><span class="line"></span><br><span class="line">var_dump($a <span class="keyword">instanceof</span> MyClass);   <span class="comment">//bool(true)</span></span><br><span class="line">var_dump($a <span class="keyword">instanceof</span> NotMyClass);   <span class="comment">//bool(false)</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以用来确定一个变量是不是继承自某一父类的子类的实例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">ParentClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$a = <span class="keyword">new</span> MyClass;</span><br><span class="line"></span><br><span class="line">var_dump($a <span class="keyword">instanceof</span> MyClass);</span><br><span class="line">var_dump($a <span class="keyword">instanceof</span> ParentClass);   <span class="comment">//bool(true)</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以用 <code>!</code> 检查对象不是某个类的实例。</p>
<p>也可用于确定一个变量是不是实现了某个<a href="https://www.php.net/manual/zh/language.oop5.interfaces.php" target="_blank" rel="noopener">接口</a>的对象的实例。</p>
<p>虽然 <em>instanceof</em> 通常直接与类名一起使用，但也可以使用对象或字符串变量。</p>
<p>instanceof 的使用还有一些陷阱必须了解。在 PHP 5.1.0 之前，如果要检查的类名称不存在，<em>instanceof</em> 会调用 <a href="https://www.php.net/manual/zh/function.autoload.php" target="_blank" rel="noopener">__autoload()</a>。另外，如果该类没有被装载则会产生一个致命错误。可以通过使用动态类引用或用一个包含类名的字符串变量来避开这种问题。</p>
<p><em>instanceof</em> 运算符是 PHP 5 引进的。在此之前用 <a href="https://www.php.net/manual/zh/function.is-a.php" target="_blank" rel="noopener">is_a()</a>，但是后来 <a href="https://www.php.net/manual/zh/function.is-a.php" target="_blank" rel="noopener">is_a()</a> 被废弃而用 <em>instanceof</em> 替代了。注意自 PHP 5.3.0 起，又恢复使用 <a href="https://www.php.net/manual/zh/function.is-a.php" target="_blank" rel="noopener">is_a()</a> 了。参见 <a href="https://www.php.net/manual/zh/function.get-class.php" target="_blank" rel="noopener">get_class()</a> 和 <a href="https://www.php.net/manual/zh/function.is-a.php" target="_blank" rel="noopener">is_a()</a>。</p>
<h2 id="流程控制">流程控制</h2>
<h3 id="不必多说的">不必多说的</h3>
<p>if，else，while, do while, for</p>
<h3 id="elseif-else-if">elseif/else if</h3>
<p>必须要注意的是 <em>elseif</em> 与 <em>else if</em> 只有在使用花括号的情况下才认为是完全相同。如果用冒号来定义 <em>if</em>/<em>elseif</em> 条件，那就不能用两个单词的 <em>else if</em>，否则 PHP 会产生解析错误。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不正确的使用方法： */</span></span><br><span class="line"><span class="keyword">if</span> ($a &gt; $b):</span><br><span class="line">    <span class="keyword">echo</span> $a.<span class="string">" is greater than "</span>.$b;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ($a == $b): <span class="comment">// 将无法编译</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"The above line causes a parse error."</span>;</span><br><span class="line"><span class="keyword">endif</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 正确的使用方法： */</span></span><br><span class="line"><span class="keyword">if</span> ($a &gt; $b):</span><br><span class="line">    <span class="keyword">echo</span> $a.<span class="string">" is greater than "</span>.$b;</span><br><span class="line"><span class="keyword">elseif</span> ($a == $b): <span class="comment">// 注意使用了一个单词的 elseif</span></span><br><span class="line">    <span class="keyword">echo</span> $a.<span class="string">" equals "</span>.$b;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">echo</span> $a.<span class="string">" is neither greater than or equal to "</span>.$b;</span><br><span class="line"><span class="keyword">endif</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="流程控制的替代语法">流程控制的替代语法</h3>
<p>PHP 提供了一些流程控制的替代语法，包括 <em>if</em>，<em>while</em>，<em>for</em>，<em>foreach</em> 和 <em>switch</em>。替代语法的基本形式是把左花括号（{）换成冒号（:），把右花括号（}）分别换成 <code>endif;</code>，<code>endwhile;</code>，<code>endfor;</code>，<code>endforeach;</code> 以及 <code>endswitch;</code>。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">if</span> ($a == <span class="number">5</span>): <span class="meta">?&gt;</span></span><br><span class="line">A is equal to <span class="number">5</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">endif</span>; <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，HTML 内容“A is equal to 5”用替代语法嵌套在 <em>if</em> 语句中。该 HTML 的内容仅在 $a 等于 5 时显示。</p>
<p>不支持在同一个控制块内混合使用两种语法。</p>
<p><em>switch</em> 和第一个 <em>case</em> 之间的任何输出（含空格）将导致语法错误。例如，这样是无效的：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">switch</span> ($foo): <span class="meta">?&gt;</span></span><br><span class="line">    <span class="meta">&lt;?php</span> <span class="keyword">case</span> <span class="number">1</span>: <span class="meta">?&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">endswitch</span> <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>而这样是有效的，因为 <em>switch</em> 之后的换行符被认为是结束标记 <em>?&gt;</em> 的一部分，所以在 <em>switch</em> 和 <em>case</em> 之间不能有任何输出：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">switch</span> ($foo): <span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">case</span> <span class="number">1</span>: <span class="meta">?&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">endswitch</span> <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="foreach">foreach</h3>
<p><em>foreach</em> 语法结构提供了遍历数组的简单方式。<em>foreach</em> 仅能够应用于数组和对象，如果尝试应用于其他数据类型的变量，或者未初始化的变量将发出错误信息。有两种语法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (array_expression <span class="keyword">as</span> $value)</span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">foreach</span> (array_expression <span class="keyword">as</span> $key =&gt; $value)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>
<p>第一种格式遍历给定的 <em>array_expression</em> 数组。每次循环中，当前单元的值被赋给 <em>$value</em> 并且数组内部的指针向前移一步（因此下一次循环中将会得到下一个单元）。</p>
<p>第二种格式做同样的事，只除了当前单元的键名也会在每次循环中被赋给变量 <em>$key</em>。</p>
<p>当 <em>foreach</em> 开始执行时，数组内部的指针会自动指向第一个单元。这意味着不需要在 <em>foreach</em> 循环之前调用 <a href="https://www.php.net/manual/zh/function.reset.php" target="_blank" rel="noopener">reset()</a>。</p>
<p>可以很容易地通过在 <em>$value</em> 之前加上 &amp; 来修改数组的元素。此方法将以<a href="https://www.php.net/manual/zh/language.references.php" target="_blank" rel="noopener">引用</a>赋值而不是拷贝一个值。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$arr = <span class="keyword">array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">foreach</span> ($arr <span class="keyword">as</span> &amp;$value) &#123;</span><br><span class="line">    $value = $value * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// $arr is now array(2, 4, 6, 8)</span></span><br><span class="line"><span class="keyword">unset</span>($value); <span class="comment">// 最后取消掉引用</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><em>$value</em> 的引用仅在被遍历的数组可以被引用时才可用（例如是个变量）。以下代码则无法运行：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="keyword">as</span> &amp;$value) &#123;</span><br><span class="line">    $value = $value * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>foreach* 不支持用“@”来抑制错误信息的能力。</p>
<p>以下代码功能完全相同：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$arr = <span class="keyword">array</span>(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>);</span><br><span class="line">reset($arr);</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">list</span>(, $value) = each($arr)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Value: $value&lt;br&gt;\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> ($arr <span class="keyword">as</span> $value) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Value: $value&lt;br /&gt;\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$arr = <span class="keyword">array</span>(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>);</span><br><span class="line">reset($arr);</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">list</span>($key, $value) = each($arr)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Key: $key; Value: $value&lt;br /&gt;\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> ($arr <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Key: $key; Value: $value&lt;br /&gt;\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="用-list-给嵌套的数组解包-¶">用 list() 给嵌套的数组解包<a href="https://www.php.net/manual/zh/control-structures.foreach.php#control-structures.foreach.list" target="_blank" rel="noopener"> ¶</a></h4>
<p><em>(PHP 5 &gt;= 5.5.0, PHP 7)</em></p>
<p>PHP 5.5 增添了遍历一个数组的数组的功能并且把嵌套的数组解包到循环变量中，只需将 <a href="https://www.php.net/manual/zh/function.list.php" target="_blank" rel="noopener">list()</a> 作为值提供。</p>
<p>例如：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$array = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> ($array <span class="keyword">as</span> <span class="keyword">list</span>($a, $b)) &#123;</span><br><span class="line">    <span class="comment">// $a contains the first element of the nested array,</span></span><br><span class="line">    <span class="comment">// and $b contains the second element.</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"A: $a; B: $b\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A: 1; B: 2</span></span><br><span class="line"><span class="comment">A: 3; B: 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="break-continue">break/continue</h3>
<p>PHP中 <em>break</em>/continue 可以接受一个可选的数字参数来决定跳出几重循环。</p>
<p>*<strong>break* 的更新记录</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">版本</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">5.4.0</td>
<td style="text-align:left"><em>break 0;</em> 不再合法。这在之前的版本被解析为 <em>break 1;</em>。</td>
</tr>
<tr>
<td style="text-align:left">5.4.0</td>
<td style="text-align:left">取消变量作为参数传递（例如 <em>$num = 2; break $num;</em>）。</td>
</tr>
</tbody>
</table>
<p>continue同break。</p>
<h3 id="switch">switch</h3>
<p>注意和其它语言不同，<a href="https://www.php.net/manual/zh/control-structures.continue.php" target="_blank" rel="noopener">continue</a> 语句作用到 switch 上的作用类似于 <em>break</em>。如果在循环中有一个 switch 并希望 continue 到外层循环中的下一轮循环，用 <em>continue 2</em>。</p>
<p><strong>注意 switch/case 作的是<a href="https://www.php.net/manual/zh/types.comparisons.php#types.comparisions-loose" target="_blank" rel="noopener">松散比较</a>。</strong></p>
<p><em>switch</em> 语句一行接一行地执行（实际上是语句接语句）。开始时没有代码被执行。仅当一个 <em>case</em> 语句中的值和 <em>switch</em> 表达式的值匹配时 PHP 才开始执行语句，<strong>直到 <em>switch</em> 的程序段结束或者遇到第一个 <em>break</em> 语句为止。如果不在 case 的语句段最后写上 <em>break</em> 的话，PHP 将继续执行下一个 case 中的语句段。</strong></p>
<p>在一个 case 中的语句也可以为空，这样只不过将控制转移到了下一个 case 中的语句。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">switch</span> ($i) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"i is less than 3 but not negative"</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"i is 3"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>一个 case 的特例是 <em>default</em>。它匹配了任何和其它 case 都不匹配的情况。例如：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">switch</span> ($i) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"i equals 0"</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"i equals 1"</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"i equals 2"</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"i is not equal to 0, 1 or 2"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>允许使用分号代替 case 语句后的冒号。</p>
<h3 id="declare">declare</h3>
<p><em>declare</em> 结构用来设定一段代码的执行指令。<em>declare</em> 的语法和其它流程控制结构相似：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> (directive)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>
<p><em>directive</em> 部分允许设定 <em>declare</em> 代码段的行为。目前只认识两个指令：<em>ticks</em>（更多信息见下面 <a href="https://www.php.net/manual/zh/control-structures.declare.php#control-structures.declare.ticks" target="_blank" rel="noopener">ticks</a> 指令）以及 <em>encoding</em>（更多信息见下面 <a href="https://www.php.net/manual/zh/control-structures.declare.php#control-structures.declare.encoding" target="_blank" rel="noopener">encoding</a> 指令）。</p>
<blockquote>
<p><strong>Note</strong>: encoding 是 PHP 5.3.0 新增指令。</p>
</blockquote>
<p><em>declare</em> 结构也可用于全局范围，影响到其后的所有代码（但如果有 <em>declare</em> 结构的文件被其它文件包含，则对包含它的父文件不起作用）。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// these are the same:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// you can use this:</span></span><br><span class="line"><span class="keyword">declare</span>(ticks=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// entire script here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or you can use this:</span></span><br><span class="line"><span class="keyword">declare</span>(ticks=<span class="number">1</span>);</span><br><span class="line"><span class="comment">// entire script here</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="Tick">Tick</h4>
<p>Tick（时钟周期）是一个在 <em>declare</em> 代码段中解释器每执行 N 条可计时的低级语句就会发生的事件。N 的值是在 <em>declare</em> 中的 <em>directive</em> 部分用 <code>ticks=N</code> 来指定的。</p>
<p>不是所有语句都可计时。通常条件表达式和参数表达式都不可计时。</p>
<p>在每个 tick 中出现的事件是由 <a href="https://www.php.net/manual/zh/function.register-tick-function.php" target="_blank" rel="noopener">register_tick_function()</a> 来指定的。更多细节见下面的例子。注意每个 tick 中可以出现多个事件。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(ticks=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// A function called on each tick event</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick_handler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"tick_handler() called\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">register_tick_function(<span class="string">'tick_handler'</span>);</span><br><span class="line"></span><br><span class="line">$a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    $a += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">print</span>($a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">tick_handler() called</span></span><br><span class="line"><span class="comment">tick_handler() called</span></span><br><span class="line"><span class="comment">tick_handler() called</span></span><br><span class="line"><span class="comment">3tick_handler() called</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//和上面的效果相同</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick_handler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"tick_handler() called\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$a = <span class="number">1</span>;</span><br><span class="line">tick_handler();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    $a += <span class="number">2</span>;</span><br><span class="line">    tick_handler();</span><br><span class="line">    <span class="keyword">print</span>($a);</span><br><span class="line">    tick_handler();</span><br><span class="line">&#125;</span><br><span class="line">tick_handler();</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="Encoding">Encoding</h4>
<p>可以用 encoding 指令来对每段脚本指定其编码方式。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">declare</span>(encoding=<span class="string">'ISO-8859-1'</span>);</span><br><span class="line"><span class="comment">// code here</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 PHP 5.3 中除非在编译时指定了 <em>–enable-zend-multibyte</em>，否则 declare 中的 encoding 值会被忽略。注意除非用 <a href="https://www.php.net/manual/zh/function.phpinfo.php" target="_blank" rel="noopener">phpinfo()</a>，否则 PHP 不会显示出是否在编译时指定了 <em>–enable-zend-multibyte</em>。参见 <a href="https://www.php.net/manual/zh/ini.core.php#ini.zend.script-encoding" target="_blank" rel="noopener">zend.script_encoding</a>。</p>
<h3 id="return">return</h3>
<p>如果在一个函数中调用 <strong>return</strong> 语句，将立即结束此函数的执行并将它的参数作为函数的值返回。<strong>return</strong> 也会终止 <a href="https://www.php.net/manual/zh/function.eval.php" target="_blank" rel="noopener">eval()</a> 语句或者脚本文件的执行。</p>
<p>如果在全局范围中调用，则当前脚本文件中止运行。如果当前脚本文件是被 <a href="https://www.php.net/manual/zh/function.include.php" target="_blank" rel="noopener">include</a> 的或者 <a href="https://www.php.net/manual/zh/function.require.php" target="_blank" rel="noopener">require</a> 的，则控制交回调用文件。此外，如果当前脚本是被 <a href="https://www.php.net/manual/zh/function.include.php" target="_blank" rel="noopener">include</a> 的，则 <strong>return</strong> 的值会被当作 <a href="https://www.php.net/manual/zh/function.include.php" target="_blank" rel="noopener">include</a> 调用的返回值。如果在主脚本文件中调用 <strong>return</strong>，则脚本中止运行。如果当前脚本文件是在 php.ini 中的配置选项 <a href="https://www.php.net/manual/zh/ini.core.php#ini.auto-prepend-file" target="_blank" rel="noopener">auto_prepend_file</a> 或者 <a href="https://www.php.net/manual/zh/ini.core.php#ini.auto-append-file" target="_blank" rel="noopener">auto_append_file</a> 所指定的，则此脚本文件中止运行。</p>
<blockquote>
<p><strong>Note</strong>: 当用引用返回值时<em>永远不要</em>使用括号，这样行不通。只能通过引用返回变量，而不是语句的结果。如果使用 <em>return ($a);</em> 时其实<strong>不是返回一个变量，而是表达式 <em>($a)</em> 的值</strong>（当然，此时该值也正是 $a 的值）。</p>
</blockquote>
<h3 id="include-require">include/require</h3>
<p>包含文件用。区别是include遇错产警告，require遇错终止。</p>
<p>如果没有给出目录（只有文件名）时则按照 <a href="https://www.php.net/manual/zh/ini.core.php#ini.include-path" target="_blank" rel="noopener">include_path</a> 指定的目录寻找。如果在 <a href="https://www.php.net/manual/zh/ini.core.php#ini.include-path" target="_blank" rel="noopener">include_path</a> 下没找到该文件则 <em>include</em> 最后才在调用脚本文件所在的目录和当前工作目录下寻找。如果定义了路径（绝对和相对）<a href="https://www.php.net/manual/zh/ini.core.php#ini.include-path" target="_blank" rel="noopener">include_path</a> 会被完全忽略。</p>
<p>当一个文件被包含时，其中所包含的代码继承了 include 所在行的<a href="https://www.php.net/manual/zh/language.variables.scope.php" target="_blank" rel="noopener">变量范围</a>。从该处开始，调用文件在该行处可用的任何变量在被调用的文件中也都可用。不过所有在包含文件中定义的函数和类都具有全局作用域（?）。</p>
<p>如果 include 出现于调用文件中的一个函数里，则被调用的文件中所包含的所有代码将表现得如同它们是在该函数内部定义的一样。所以它将遵循该函数的变量范围。此规则的一个例外是<a href="https://www.php.net/manual/zh/language.constants.predefined.php" target="_blank" rel="noopener">魔术常量</a>，它们是在发生包含之前就已被解析器处理的。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">global</span> $color;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">include</span> <span class="string">'vars.php'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"A $color $fruit"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* vars.php is in the scope of foo() so     *</span></span><br><span class="line"><span class="comment"> * $fruit is NOT available outside of this  *</span></span><br><span class="line"><span class="comment"> * scope.  $color is because we declared it *</span></span><br><span class="line"><span class="comment"> * as global.                               */</span></span><br><span class="line"></span><br><span class="line">foo();                    <span class="comment">// A green apple</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"A $color $fruit"</span>;   <span class="comment">// A green</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>当一个文件被包含时，语法解析器在目标文件的开头脱离 PHP 模式并进入 HTML 模式，到文件结尾处恢复。由于此原因，目标文件中需要作为 PHP 代码执行的任何代码都必须被包括在<a href="https://www.php.net/manual/zh/language.basic-syntax.phpmode.php" target="_blank" rel="noopener">有效的 PHP 起始和结束标记</a>之中。（文件中的html内容会被直接显示出来。）</p>
<p>如果“<a href="https://www.php.net/manual/zh/filesystem.configuration.php#ini.allow-url-include" target="_blank" rel="noopener">URL include wrappers</a>”在 PHP 中被激活，可以用 URL（通过 HTTP 或者其它支持的封装协议——见<a href="https://www.php.net/manual/zh/wrappers.php" target="_blank" rel="noopener">支持的协议和封装协议</a>）而不是本地文件来指定要被包含的文件（远程包含）。如果目标服务器将目标文件作为 PHP 代码解释，则可以用适用于 HTTP GET 的 URL 请求字符串来向被包括的文件传递变量。严格的说这和包含一个文件并继承父文件的变量空间并不是一回事；该脚本文件实际上已经在远程服务器上运行了，而本地脚本则包括了其结果。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This example assumes that www.example.com is configured to parse .php *</span></span><br><span class="line"><span class="comment"> * files and not .txt files. Also, 'Works' here means that the variables *</span></span><br><span class="line"><span class="comment"> * $foo and $bar are available within the included file.                 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Won't work; file.txt wasn't handled by www.example.com as PHP</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">'http://www.example.com/file.txt?foo=1&amp;bar=2'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Won't work; looks for a file named 'file.php?foo=1&amp;bar=2' on the</span></span><br><span class="line"><span class="comment">// local filesystem.</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">'file.php?foo=1&amp;bar=2'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Works.</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">'http://www.example.com/file.php?foo=1&amp;bar=2'</span>;</span><br><span class="line"></span><br><span class="line">$foo = <span class="number">1</span>;</span><br><span class="line">$bar = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">include</span> <span class="string">'file.txt'</span>;  <span class="comment">// Works.</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">'file.php'</span>;  <span class="comment">// Works.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为 <em>include</em> 是一个特殊的语言结构，其参数不需要括号。在比较其返回值时要注意。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// won't work, evaluated as include(('vars.php') == TRUE), i.e. include('')</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">include</span>(<span class="string">'vars.php'</span>) == <span class="keyword">TRUE</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'OK'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// works</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">include</span> <span class="string">'vars.php'</span>) == <span class="keyword">TRUE</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'OK'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>include和return：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span>.php</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$var = <span class="string">'PHP'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> $var;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">noreturn.php</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$var = <span class="string">'PHP'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">testreturns.php</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$foo = <span class="keyword">include</span> <span class="string">'return.php'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $foo; <span class="comment">// prints 'PHP'</span></span><br><span class="line"></span><br><span class="line">$bar = <span class="keyword">include</span> <span class="string">'noreturn.php'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $bar; <span class="comment">// prints 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果在包含文件中定义有函数，这些函数不管是在 <a href="https://www.php.net/manual/zh/function.return.php" target="_blank" rel="noopener">return</a> 之前还是之后定义的，都可以独立在主文件中使用。如果文件被包含两次，PHP 5 发出致命错误因为函数已经被定义，但是 PHP 4 不会对在 <a href="https://www.php.net/manual/zh/function.return.php" target="_blank" rel="noopener">return</a> 之后定义的函数报错。推荐使用 <a href="https://www.php.net/manual/zh/function.include-once.php" target="_blank" rel="noopener">include_once</a> 而不是检查文件是否已包含并在包含文件中有条件返回。</p>
<p>将 PHP 文件“包含”到一个变量中的方法是用<a href="https://www.php.net/manual/zh/ref.outcontrol.php" target="_blank" rel="noopener">输出控制函数</a>结合 <strong>include</strong> 来捕获其输出，例如：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$string = get_include_contents(<span class="string">'somefile.php'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_include_contents</span><span class="params">($filename)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_file($filename)) &#123;</span><br><span class="line">        ob_start();</span><br><span class="line">        <span class="keyword">include</span> $filename;</span><br><span class="line">        $contents = ob_get_contents();</span><br><span class="line">        ob_end_clean();</span><br><span class="line">        <span class="keyword">return</span> $contents;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>要在脚本中自动包含文件，参见 php.ini 中的 <a href="https://www.php.net/manual/zh/ini.core.php#ini.auto-prepend-file" target="_blank" rel="noopener">auto_prepend_file</a> 和 <a href="https://www.php.net/manual/zh/ini.core.php#ini.auto-append-file" target="_blank" rel="noopener">auto_append_file</a> 配置选项。</p>
<blockquote>
<p><strong>Note</strong>: 因为是一个语言构造器而不是一个函数，不能被 <a href="https://www.php.net/manual/zh/functions.variable-functions.php" target="_blank" rel="noopener">可变函数</a> 调用。</p>
</blockquote>
<h3 id="include-once-require-once">include_once/require_once</h3>
<p>只包含一次。</p>
<blockquote>
<p>Note:</p>
<p>在 PHP 4中，_once 的行为在不区分大小写字母的操作系统（例如 Windows）中有所不同，例如：</p>
<p>Example #1 include_once 在 PHP 4 运行于不区分大小写的操作系统中</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include_once</span> <span class="string">"a.php"</span>; <span class="comment">// 这将包含 a.php</span></span><br><span class="line"><span class="keyword">include_once</span> <span class="string">"A.php"</span>; <span class="comment">// 这将再次包含 a.php！（仅 PHP 4）</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>此行为在 PHP 5 中改了，例如在 Windows 中路径先被规格化，因此 C:\PROGRA~1\A.php 和 C:\Program Files\a.php 的实现一样，文件只会被包含一次。</p>
</blockquote>
<h3 id="goto">goto</h3>
<p>PHP 中的 <em>goto</em> 有一定限制，目标位置只能位于同一个文件和作用域，也就是说无法跳出一个函数或类方法，也无法跳入到另一个函数。也无法跳入到任何循环或者 switch 结构中。可以跳出循环或者 switch，通常的用法是用 <em>goto</em> 代替多层的 <em>break</em>。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">for</span>($i=<span class="number">0</span>,$j=<span class="number">50</span>; $i&lt;<span class="number">100</span>; $i++) &#123;</span><br><span class="line">  <span class="keyword">while</span>($j--) &#123;</span><br><span class="line">    <span class="keyword">if</span>($j==<span class="number">17</span>) <span class="keyword">goto</span> end; </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"i = $i"</span>;</span><br><span class="line">end:</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'j hit 17'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 无效写法</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">goto</span> loop;</span><br><span class="line"><span class="keyword">for</span>($i=<span class="number">0</span>,$j=<span class="number">50</span>; $i&lt;<span class="number">100</span>; $i++) &#123;</span><br><span class="line">  <span class="keyword">while</span>($j--) &#123;</span><br><span class="line">    loop:</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"$i = $i"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Note</strong>:</p>
<p>goto 操作符仅在 PHP 5.3及以上版本有效。</p>
</blockquote>
<h2 id="函数">函数</h2>
<h3 id="自定义函数">自定义函数</h3>
<p>任何有效的 PHP 代码都有可能出现在函数内部，甚至包括其它函数和<a href="https://www.php.net/manual/zh/language.oop5.basic.php#language.oop5.basic.class" target="_blank" rel="noopener">类</a>定义。</p>
<p>函数无需在调用之前被定义，<em>除非</em>是下面两个例子中函数是有条件被定义时。当一个函数是有条件被定义时，必须在调用函数<em>之前</em>定义。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$makefoo = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不能在此处调用foo()函数，</span></span><br><span class="line"><span class="comment">   因为它还不存在，但可以调用bar()函数。*/</span></span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($makefoo) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"I don't exist until program execution reaches me.\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 现在可以安全调用函数 foo()了，</span></span><br><span class="line"><span class="comment">   因为 $makefoo 值为真 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($makefoo) foo();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"I exist immediately upon program start.\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"I don't exist until foo() is called.\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 现在还不能调用bar()函数，因为它还不存在 */</span></span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 现在可以调用bar()函数了，因为foo()函数</span></span><br><span class="line"><span class="comment">   的执行使得bar()函数变为已定义的函数 */</span></span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="递归函数"><strong>递归函数</strong></h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursion</span><span class="params">($a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ($a &lt; <span class="number">20</span>) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"$a\n"</span>;</span><br><span class="line">        recursion($a + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Note</strong>: 但是要避免递归函数／方法调用超过 100-200 层，因为可能会使堆栈崩溃从而使当前脚本终止。 无限递归可视为编程错误。</p>
</blockquote>
<h3 id="函数参数">函数参数</h3>
<p>注意当使用默认参数时，任何默认参数必须放在任何非默认参数的右侧；否则，函数将不会按照预期的情况工作。考虑下面的代码片断：</p>
<p><strong>函数默认参数的不正确用法</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeyogurt</span><span class="params">($type = <span class="string">"acidophilus"</span>, $flavour)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Making a bowl of $type $flavour.\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> makeyogurt(<span class="string">"raspberry"</span>);   <span class="comment">// won't work as expected</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上例程会输出：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Warning</span>: Missing argument <span class="number">2</span> <span class="keyword">in</span> <span class="keyword">call</span> <span class="keyword">to</span> makeyogurt() <span class="keyword">in</span> </span><br><span class="line">/usr/<span class="keyword">local</span>/etc/httpd/htdocs/phptest/functest.html <span class="keyword">on</span> <span class="type">line</span> <span class="number">41</span></span><br><span class="line">Making a bowl <span class="keyword">of</span> raspberry .</span><br></pre></td></tr></table></figure>
<p>正确用法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeyogurt</span><span class="params">($flavour, $type = <span class="string">"acidophilus"</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Making a bowl of $type $flavour.\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> makeyogurt(<span class="string">"raspberry"</span>);   <span class="comment">// works as expected</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="参数类型">参数类型</h3>
<table>
<thead>
<tr>
<th style="text-align:left">type</th>
<th style="text-align:left">Description</th>
<th style="text-align:left">Minimum PHP version</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Class/interface name</td>
<td style="text-align:left">The parameter must be an <a href="https://www.php.net/manual/zh/language.operators.type.php" target="_blank" rel="noopener"><em>instanceof</em></a> the given class or interface name.</td>
<td style="text-align:left">PHP 5.0.0</td>
</tr>
<tr>
<td style="text-align:left"><em>self</em></td>
<td style="text-align:left">The parameter must be an <a href="https://www.php.net/manual/zh/language.operators.type.php" target="_blank" rel="noopener"><em>instanceof</em></a> the same class as the one the method is defined on. This can only be used on class and instance methods.</td>
<td style="text-align:left">PHP 5.0.0</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.types.array.php" target="_blank" rel="noopener">array</a></td>
<td style="text-align:left">The parameter must be an <a href="https://www.php.net/manual/zh/language.types.array.php" target="_blank" rel="noopener">array</a>.</td>
<td style="text-align:left">PHP 5.1.0</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.types.callable.php" target="_blank" rel="noopener">callable</a></td>
<td style="text-align:left">The parameter must be a valid <a href="https://www.php.net/manual/zh/language.types.callable.php" target="_blank" rel="noopener">callable</a>.</td>
<td style="text-align:left">PHP 5.4.0</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.types.boolean.php" target="_blank" rel="noopener">bool</a></td>
<td style="text-align:left">The parameter must be a <a href="https://www.php.net/manual/zh/language.types.boolean.php" target="_blank" rel="noopener">boolean</a> value.</td>
<td style="text-align:left">PHP 7.0.0</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.types.float.php" target="_blank" rel="noopener">float</a></td>
<td style="text-align:left">The parameter must be a <a href="https://www.php.net/manual/zh/language.types.float.php" target="_blank" rel="noopener">float</a>ing point number.</td>
<td style="text-align:left">PHP 7.0.0</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.types.integer.php" target="_blank" rel="noopener">int</a></td>
<td style="text-align:left">The parameter must be an <a href="https://www.php.net/manual/zh/language.types.integer.php" target="_blank" rel="noopener">integer</a>.</td>
<td style="text-align:left">PHP 7.0.0</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.php.net/manual/zh/language.types.string.php" target="_blank" rel="noopener">string</a></td>
<td style="text-align:left">The parameter must be a <a href="https://www.php.net/manual/zh/language.types.string.php" target="_blank" rel="noopener">string</a>.</td>
<td style="text-align:left">PHP 7.0.0</td>
</tr>
<tr>
<td style="text-align:left"><em>iterable</em></td>
<td style="text-align:left">The parameter must be either an <a href="https://www.php.net/manual/zh/language.types.array.php" target="_blank" rel="noopener">array</a> or an <a href="https://www.php.net/manual/zh/language.operators.type.php" target="_blank" rel="noopener"><em>instanceof</em></a> <strong>Traversable</strong>.</td>
<td style="text-align:left">PHP 7.1.0</td>
</tr>
<tr>
<td style="text-align:left"><em>object</em></td>
<td style="text-align:left">The parameter must be an <a href="https://www.php.net/manual/zh/language.types.object.php" target="_blank" rel="noopener">object</a>.</td>
<td style="text-align:left">PHP 7.2.0</td>
</tr>
</tbody>
</table>
<p><strong>Nullable type declaration</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(C $c = null)</span> </span>&#123;</span><br><span class="line">    var_dump($c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="keyword">new</span> C);</span><br><span class="line">f(<span class="keyword">null</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="严格类型">严格类型</h4>
<p>默认情况下，如果能做到的话，PHP将会强迫错误类型的值转为函数期望的标量类型。 例如，一个函数的一个参数期望是<a href="https://www.php.net/manual/zh/language.types.string.php" target="_blank" rel="noopener">string</a>，但传入的是<a href="https://www.php.net/manual/zh/language.types.integer.php" target="_blank" rel="noopener">integer</a>，最终函数得到的将会是一个<a href="https://www.php.net/manual/zh/language.types.string.php" target="_blank" rel="noopener">string</a>类型的值。</p>
<p>可以基于每一个文件开启严格模式。在严格模式中，只有一个与类型声明完全相符的变量才会被接受，否则将会抛出一个<strong>TypeError</strong>。 唯一的一个例外是可以将<a href="https://www.php.net/manual/zh/language.types.integer.php" target="_blank" rel="noopener">integer</a>传给一个期望<a href="https://www.php.net/manual/zh/language.types.float.php" target="_blank" rel="noopener">float</a>的函数。</p>
<p>实例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(int $a, int $b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $a + $b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    var_dump(sum(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    var_dump(sum(<span class="number">1.5</span>, <span class="number">2.5</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (TypeError $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'Error: '</span>.$e-&gt;getMessage();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int(3)</span></span><br><span class="line"><span class="comment">Error: Argument 1 passed to sum() must be of the type integer, float given, called in - on line 10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="可变数量的参数列表">可变数量的参数列表</h4>
<p>PHP 在用户自定义函数中支持可变数量的参数列表。在 PHP 5.6 及以上的版本中，由 <em>…</em> 语法实现；在 PHP 5.5 及更早版本中，使用函数 <a href="https://www.php.net/manual/zh/function.func-num-args.php" target="_blank" rel="noopener">func_num_args()</a>，<a href="https://www.php.net/manual/zh/function.func-get-arg.php" target="_blank" rel="noopener">func_get_arg()</a>，和 <a href="https://www.php.net/manual/zh/function.func-get-args.php" target="_blank" rel="noopener">func_get_args()</a> 。</p>
<p><em>…</em> in PHP 5.6+，例如：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(...$numbers)</span> </span>&#123;</span><br><span class="line">    $acc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> ($numbers <span class="keyword">as</span> $n) &#123;</span><br><span class="line">        $acc += $n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $acc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以用…把list解压到参数列表中：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">($a, $b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $a + $b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> add(...[<span class="number">1</span>, <span class="number">2</span>]).<span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">$a = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">echo</span> add(...$a);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>在老版本（低于5.5）时，不需要特殊语法标注可变，但是需要使用函数，例如： <a href="https://www.php.net/manual/zh/function.func-num-args.php" target="_blank" rel="noopener">func_num_args()</a>, <a href="https://www.php.net/manual/zh/function.func-get-arg.php" target="_blank" rel="noopener">func_get_arg()</a> 和 <a href="https://www.php.net/manual/zh/function.func-get-args.php" target="_blank" rel="noopener">func_get_args()</a>.</p>
<p>实例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    $acc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (func_get_args() <span class="keyword">as</span> $n) &#123;</span><br><span class="line">        $acc += $n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $acc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="返回值">返回值</h3>
<p>函数不能返回多个值，但可以通过返回一个数组来得到类似的效果。</p>
<p>从函数返回一个引用，必须在函数声明和指派返回值给一个变量时都使用引用运算符 &amp;。例如：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> &amp;<span class="title">returns_reference</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $someref;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$newref =&amp; returns_reference();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>PHP 7 增加了对返回值类型声明的支持。在默认的弱模式中，如果返回值与返回值的类型不一致，则会被强制转换为返回值声明的类型。在强模式中，返回值的类型必须正确，否则将会抛出一个<strong>TypeError</strong>异常。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">($a, $b)</span>: <span class="title">int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $a + $b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump(sum(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">var_dump(sum(<span class="number">1</span>, <span class="number">2.5</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int(3)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Fatal error: Uncaught TypeError: Return value of sum() must be of the type integer, float returned in - on line 5 in -:5</span></span><br><span class="line"><span class="comment">Stack trace:</span></span><br><span class="line"><span class="comment">#0 -(9): sum(1, 2.5)</span></span><br><span class="line"><span class="comment">#1 &#123;main&#125;</span></span><br><span class="line"><span class="comment">  thrown in - on line 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>返回对象：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getC</span><span class="params">()</span>: <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump(getC());</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>返回null（PHP 7.1.0+）：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_item</span><span class="params">()</span>: ?<span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'item'</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> $_GET[<span class="string">'item'</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="可变函数">可变函数</h3>
<p>一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它。可变函数可以用来实现包括回调函数，函数表在内的一些用途。</p>
<p>实例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Variable</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $name = <span class="string">'Bar'</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;$name(); <span class="comment">// This calls the Bar() method</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"This is Bar"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$foo = <span class="keyword">new</span> Foo();</span><br><span class="line">$funcname = <span class="string">"Variable"</span>;</span><br><span class="line">$foo-&gt;$funcname();   <span class="comment">// This calls $foo-&gt;Variable()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>当调用静态方法时，函数调用要比静态属性优先。</p>
<p>调用数组和类中的方法，例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"bar\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">baz</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"baz\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$func = <span class="keyword">array</span>(<span class="string">"Foo"</span>, <span class="string">"bar"</span>);</span><br><span class="line">$func(); <span class="comment">// prints "bar"</span></span><br><span class="line">$func = <span class="keyword">array</span>(<span class="keyword">new</span> Foo, <span class="string">"baz"</span>);</span><br><span class="line">$func(); <span class="comment">// prints "baz"</span></span><br><span class="line">$func = <span class="string">"Foo::bar"</span>;</span><br><span class="line">$func(); <span class="comment">// prints "bar" as of PHP 7.0.0; prior, it raised a fatal error</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">版本</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">7.0.0</td>
<td style="text-align:left">‘ClassName::methodName’ is allowed as variable function.</td>
</tr>
<tr>
<td style="text-align:left">5.4.0</td>
<td style="text-align:left">Arrays, which are valid callables, are allowed as variable functions.</td>
</tr>
</tbody>
</table>
<h3 id="内置函数">内置函数</h3>
<p>PHP手册中每一个函数的页面中都有关于函数参数、行为改变、成功与否的返回值以及使用条件等信息。了解这些重要的（常常是细微的）差别是编写正确的 PHP 代码的关键。</p>
<p>有时需要加载模块（和扩展模块一起编译）以使用模块中的函数。</p>
<h3 id="匿名函数">匿名函数</h3>
<p>也叫闭包函数。允许临时创建一个没有指定名称的函数。</p>
<h3 id="Arrow函数">Arrow函数</h3>
<p>PHP 7.4之后新增的使匿名函数语法更简洁的函数。</p>
<h2 id="类与对象">类与对象</h2>
<h3 id="基本概念">基本概念</h3>
<h4 id="简单的类定义">简单的类定义</h4>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 声明属性</span></span><br><span class="line">    <span class="keyword">public</span> $var = <span class="string">'a default value'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">displayVar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;var;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>当一个方法在类定义内部被调用时，有一个可用的伪变量 $this。$this 是一个到主叫对象的引用（通常是该方法所从属的对象，但如果是从第二个对象<a href="https://www.php.net/manual/zh/language.oop5.static.php" target="_blank" rel="noopener">静态</a>调用时也可能是另一个对象）。</p>
<p>示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>)) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">'$this is defined ('</span>;</span><br><span class="line">            <span class="keyword">echo</span> get_class(<span class="keyword">$this</span>);</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">")\n"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"\$this is not defined.\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        A::foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$a = <span class="keyword">new</span> A();</span><br><span class="line">$a-&gt;foo();</span><br><span class="line"></span><br><span class="line">A::foo();</span><br><span class="line"></span><br><span class="line">$b = <span class="keyword">new</span> B();</span><br><span class="line">$b-&gt;bar();</span><br><span class="line"></span><br><span class="line">B::bar();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>Output of the above example in PHP 5:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">$this</span> is defined (A)</span><br><span class="line"><span class="keyword">$this</span> is not defined.</span><br><span class="line"><span class="keyword">$this</span> is defined (B)</span><br><span class="line"><span class="keyword">$this</span> is not defined.</span><br></pre></td></tr></table></figure>
<p>Output of the above example in PHP 7:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">$this</span> is defined (A)</span><br><span class="line"><span class="keyword">$this</span> is not defined.</span><br><span class="line"><span class="keyword">$this</span> is not defined.</span><br><span class="line"><span class="keyword">$this</span> is not defined.</span><br></pre></td></tr></table></figure>
<h4 id="new">new</h4>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$instance = <span class="keyword">new</span> SimpleClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以这样做：</span></span><br><span class="line">$className = <span class="string">'Foo'</span>;</span><br><span class="line">$instance = <span class="keyword">new</span> $className(); <span class="comment">// Foo()</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>在类定义内部，可以用 <em>new self</em> 和 <em>new parent</em> 创建新对象。</p>
<p>当把一个对象已经创建的实例赋给一个新变量时，新变量会访问同一个实例，就和用该对象赋值一样。此行为和给函数传递入实例时一样。可以用<a href="https://www.php.net/manual/zh/language.oop5.cloning.php" target="_blank" rel="noopener">克隆</a>给一个已创建的对象建立一个新实例。</p>
<h4 id="对象赋值">对象赋值</h4>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$instance = <span class="keyword">new</span> SimpleClass();</span><br><span class="line"></span><br><span class="line">$assigned   =  $instance;</span><br><span class="line">$reference  =&amp; $instance;</span><br><span class="line"></span><br><span class="line">$instance-&gt;var = <span class="string">'$assigned will have this value'</span>;</span><br><span class="line"></span><br><span class="line">$instance = <span class="keyword">null</span>; <span class="comment">// $instance and $reference become null</span></span><br><span class="line"></span><br><span class="line">var_dump($instance);</span><br><span class="line">var_dump($reference);</span><br><span class="line">var_dump($assigned);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上例程会输出：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">NULL</span></span><br><span class="line">object(SimpleClass)<span class="comment">#1 (1) &#123;</span></span><br><span class="line">   [<span class="string">"var"</span>]=&gt;</span><br><span class="line">     string(<span class="number">30</span>) <span class="string">"$assigned will have this value"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PHP 5.4.0 起，可以通过一个表达式来访问新创建对象的成员：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> (<span class="keyword">new</span> DateTime())-&gt;format(<span class="string">'Y'</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上例程的输出类似于：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2016</span></span><br></pre></td></tr></table></figure>
<h3 id="属性">属性</h3>
<p>类的变量成员叫做“属性”。</p>
<p>属性声明是由关键字 <em>public</em>，<em>protected</em> 或者 <em>private</em> 开头，然后跟一个普通的变量声明来组成。属性中的变量可以初始化，但是初始化的值必须是常数，这里的常数是指 PHP 脚本在编译阶段时就可以得到其值，而不依赖于运行时的信息才能求值。</p>
<p>为了向后兼容 PHP 4，PHP 5 声明属性依然可以直接使用关键字 <em>var</em> 来替代（或者附加于）<em>public</em>，<em>protected</em> 或 <em>private</em>。但是已不再需要 <em>var</em> 了。如果直接使用 <em>var</em> 声明属性，而没有用 <em>public</em>，<em>protected</em> 或 <em>private</em> 之一，PHP 5 会将其视为 <em>public</em>。</p>
<p>在类的成员方法里面，可以用 <em>-&gt;</em>（对象运算符）：$this-&gt;property（其中 <em>property</em> 是该属性名）这种方式来访问非静态属性。静态属性则是用 <em>::</em>（双冒号）：self::$property 来访问。更多静态属性与非静态属性的区别参见 <a href="https://www.php.net/manual/zh/language.oop5.static.php" target="_blank" rel="noopener">Static 关键字</a>。</p>
<p>实例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="comment">// 错误的属性声明</span></span><br><span class="line">   <span class="keyword">public</span> $var1 = <span class="string">'hello '</span> . <span class="string">'world'</span>;</span><br><span class="line">   <span class="keyword">public</span> $var2 = <span class="string">&lt;&lt;&lt;EOD</span></span><br><span class="line"><span class="string">hello world</span></span><br><span class="line"><span class="string">EOD;</span></span><br><span class="line">   <span class="keyword">public</span> $var3 = <span class="number">1</span>+<span class="number">2</span>;</span><br><span class="line">   <span class="keyword">public</span> $var4 = <span class="keyword">self</span>::myStaticMethod();</span><br><span class="line">   <span class="keyword">public</span> $var5 = $myVar;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 正确的属性声明</span></span><br><span class="line">   <span class="keyword">public</span> $var6 = myConstant;</span><br><span class="line">   <span class="keyword">public</span> $var7 = <span class="keyword">array</span>(<span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//在 PHP 5.3.0 及之后，下面的声明也正确(newdoc)</span></span><br><span class="line">   <span class="keyword">public</span> $var8 = <span class="string">&lt;&lt;&lt;'EOD'</span></span><br><span class="line"><span class="string">hello world</span></span><br><span class="line"><span class="string">EOD;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="类常量">类常量</h3>
<p>可以把在类中始终保持不变的值定义为常量。在定义和使用常量的时候不需要使用 $ 符号。</p>
<p>常量的值必须是一个定值，不能是变量，类属性，数学运算的结果或函数调用。</p>
<p>实例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> constant = <span class="string">'constant value'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">showConstant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span>  <span class="keyword">self</span>::constant . <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> MyClass::constant . <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">$classname = <span class="string">"MyClass"</span>;</span><br><span class="line"><span class="keyword">echo</span> $classname::constant . <span class="string">"\n"</span>; <span class="comment">// 自 5.3.0 起</span></span><br><span class="line"></span><br><span class="line">$class = <span class="keyword">new</span> MyClass();</span><br><span class="line">$class-&gt;showConstant();</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $class::constant.<span class="string">"\n"</span>; <span class="comment">// 自 PHP 5.3.0 起</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="类的自动加载">类的自动加载</h3>
<p>在编写面向对象（OOP） 程序时，很多开发者为每个类新建一个 PHP 文件。 这会带来一个烦恼：每个脚本的开头，都需要包含（include）一个长长的列表（每个类都有个文件）。</p>
<p>在 PHP 5 中，已经不再需要这样了。 <a href="https://www.php.net/manual/zh/function.spl-autoload-register.php" target="_blank" rel="noopener">spl_autoload_register()</a> 函数可以注册任意数量的自动加载器，当使用尚未被定义的类（class）和接口（interface）时自动去加载。通过注册自动加载器，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类。</p>
<p>自动加载不可用于 PHP 的 CLI <a href="https://www.php.net/manual/zh/features.commandline.php" target="_blank" rel="noopener">交互模式</a>。</p>
<p>实例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">spl_autoload_register(<span class="function"><span class="keyword">function</span> <span class="params">($class_name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">require_once</span> $class_name . <span class="string">'.php'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$obj  = <span class="keyword">new</span> MyClass1();</span><br><span class="line">$obj2 = <span class="keyword">new</span> MyClass2();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="构造函数和析构函数">构造函数和析构函数</h3>
<h4 id="construct">__construct()</h4>
<p>创建新对象时先调用此方法。初始化。</p>
<blockquote>
<p><strong>Note</strong>: 如果子类中定义了构造函数则不会隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用 <strong>parent::__construct()</strong>。如果子类没有定义构造函数则会如同一个普通的类方法一样从父类继承（假如没有被定义为 private 的话）。</p>
</blockquote>
<h4 id="destruct">__destruct()</h4>
<p>析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。</p>
<p>和构造函数一样，父类的析构函数不会被引擎暗中调用。要执行父类的析构函数，必须在子类的析构函数体中显式调用 <strong>parent::__destruct()</strong>。此外也和构造函数一样，子类如果自己没有定义析构函数则会继承父类的。</p>
<p>析构函数即使在使用 <a href="https://www.php.net/manual/zh/function.exit.php" target="_blank" rel="noopener">exit()</a> 终止脚本运行时也会被调用。在析构函数中调用 <a href="https://www.php.net/manual/zh/function.exit.php" target="_blank" rel="noopener">exit()</a> 将会中止其余关闭操作的运行。</p>
<blockquote>
<p><strong>Note</strong>: 试图在析构函数（在脚本终止时被调用）中抛出一个异常会导致致命错误。</p>
</blockquote>
<h3 id="访问控制（可见性）">访问控制（可见性）</h3>
<p>对属性或方法的访问控制，是通过在前面添加关键字 <em>public</em>（公有），<em>protected</em>（受保护）或 <em>private</em>（私有）来实现的。被定义为公有的类成员可以在任何地方被访问。被定义为受保护的类成员则可以被其自身以及其子类和父类访问。被定义为私有的类成员则只能被其定义所在的类访问。</p>
<h4 id="属性-2">属性</h4>
<p>类属性必须定义为公有，受保护，私有之一。如果用 <em>var</em> 定义，则被视为公有。</p>
<p>实例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define MyClass</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $public = <span class="string">'Public'</span>;</span><br><span class="line">    <span class="keyword">protected</span> $protected = <span class="string">'Protected'</span>;</span><br><span class="line">    <span class="keyword">private</span> $private = <span class="string">'Private'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">printHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;public;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;protected;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;private;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$obj = <span class="keyword">new</span> MyClass();</span><br><span class="line"><span class="keyword">echo</span> $obj-&gt;public; <span class="comment">// 这行能被正常执行</span></span><br><span class="line"><span class="keyword">echo</span> $obj-&gt;protected; <span class="comment">// 这行会产生一个致命错误</span></span><br><span class="line"><span class="keyword">echo</span> $obj-&gt;private; <span class="comment">// 这行也会产生一个致命错误</span></span><br><span class="line">$obj-&gt;printHello(); <span class="comment">// 输出 Public、Protected 和 Private</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define MyClass2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass2</span> <span class="keyword">extends</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 可以对 public 和 protected 进行重定义，但 private 而不能</span></span><br><span class="line">    <span class="keyword">protected</span> $protected = <span class="string">'Protected2'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">printHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;public;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;protected;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;private;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$obj2 = <span class="keyword">new</span> MyClass2();</span><br><span class="line"><span class="keyword">echo</span> $obj2-&gt;public; <span class="comment">// 这行能被正常执行</span></span><br><span class="line"><span class="keyword">echo</span> $obj2-&gt;private; <span class="comment">// 未定义 private</span></span><br><span class="line"><span class="keyword">echo</span> $obj2-&gt;protected; <span class="comment">// 这行会产生一个致命错误</span></span><br><span class="line">$obj2-&gt;printHello(); <span class="comment">// 输出 Public、Protected2 和 Undefined</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="方法">方法</h4>
<p>类中的方法可以被定义为公有，私有或受保护。如果没有设置这些关键字，则该方法默认为公有。</p>
<p>实例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define MyClass</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个公有的构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个公有的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">MyPublic</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个受保护的方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">MyProtected</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个私有的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">MyPrivate</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此方法为公有</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;MyPublic();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;MyProtected();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;MyPrivate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$myclass = <span class="keyword">new</span> MyClass;</span><br><span class="line">$myclass-&gt;MyPublic(); <span class="comment">// 这行能被正常执行</span></span><br><span class="line">$myclass-&gt;MyProtected(); <span class="comment">// 这行会产生一个致命错误</span></span><br><span class="line">$myclass-&gt;MyPrivate(); <span class="comment">// 这行会产生一个致命错误</span></span><br><span class="line">$myclass-&gt;Foo(); <span class="comment">// 公有，受保护，私有都可以执行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define MyClass2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass2</span> <span class="keyword">extends</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 此方法为公有</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Foo2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;MyPublic();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;MyProtected();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;MyPrivate(); <span class="comment">// 这行会产生一个致命错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$myclass2 = <span class="keyword">new</span> MyClass2;</span><br><span class="line">$myclass2-&gt;MyPublic(); <span class="comment">// 这行能被正常执行</span></span><br><span class="line">$myclass2-&gt;Foo2(); <span class="comment">// 公有的和受保护的都可执行，但私有的不行</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;testPrivate();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;testPublic();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testPublic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Bar::testPublic\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">testPrivate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Bar::testPrivate\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">Bar</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testPublic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Foo::testPublic\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">testPrivate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Foo::testPrivate\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$myFoo = <span class="keyword">new</span> foo();</span><br><span class="line">$myFoo-&gt;test(); <span class="comment">// Bar::testPrivate </span></span><br><span class="line">                <span class="comment">// Foo::testPublic</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="继承">继承</h3>
<p>当扩展一个类，子类就会继承父类所有公有的和受保护的方法。除非子类覆盖了父类的方法，被继承的方法都会保留其原有功能。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bar</span> <span class="keyword">extends</span> <span class="title">foo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// codes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="范围解析操作符-（-）">范围解析操作符 （::）</h3>
<p>可以用于访问<a href="https://www.php.net/manual/zh/language.oop5.static.php" target="_blank" rel="noopener">静态</a>成员，<a href="https://www.php.net/manual/zh/language.oop5.constants.php" target="_blank" rel="noopener">类常量</a>，还可以用于覆盖类中的属性和方法。</p>
<p>实例：</p>
<p>在类定义外部使用：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> CONST_VALUE = <span class="string">'A constant value'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$classname = <span class="string">'MyClass'</span>;</span><br><span class="line"><span class="keyword">echo</span> $classname::CONST_VALUE; <span class="comment">// 自 PHP 5.3.0 起</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> MyClass::CONST_VALUE;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>self，parent 和 static 这三个特殊的关键字是用于在类定义的内部对其属性或方法进行访问的。</p>
<p>在类定义内部使用：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OtherClass</span> <span class="keyword">extends</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> $my_static = <span class="string">'static var'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">doubleColon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">parent</span>::CONST_VALUE . <span class="string">"\n"</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">self</span>::$my_static . <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$classname = <span class="string">'OtherClass'</span>;</span><br><span class="line"><span class="keyword">echo</span> $classname::doubleColon(); <span class="comment">// 自 PHP 5.3.0 起</span></span><br><span class="line"></span><br><span class="line">OtherClass::doubleColon();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>调用父类方法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"MyClass::myFunc()\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OtherClass</span> <span class="keyword">extends</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 覆盖了父类的定义</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 但还是可以调用父类中被覆盖的方法</span></span><br><span class="line">        <span class="keyword">parent</span>::myFunc();</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"OtherClass::myFunc()\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$class = <span class="keyword">new</span> OtherClass();</span><br><span class="line">$class-&gt;myFunc();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Static-2">Static</h3>
<p>声明类属性或方法为静态，就可以不实例化类而直接访问。静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。</p>
<p>由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。</p>
<p>静态属性不可以由对象通过 -&gt; 操作符来访问。</p>
<h3 id="抽象类">抽象类</h3>
<p>定义为抽象的类不能被实例化。如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；另外，这些方法的<a href="https://www.php.net/manual/zh/language.oop5.visibility.php" target="_blank" rel="noopener">访问控制</a>必须和父类中一样（或者更为宽松）。</p>
<h3 id="重载">重载</h3>
<p>动态地创建类属性和方法。通过魔术方法（magic methods）来实现。</p>
<p>当调用当前环境下未定义或不<a href="https://www.php.net/manual/zh/language.oop5.visibility.php" target="_blank" rel="noopener">可见</a>的类属性或方法时，重载方法会被调用。</p>
<p>所有的重载方法都必须被声明为 <em>public</em>。</p>
<h4 id="属性重载">属性重载</h4>
<p>在给不可访问属性赋值时，<a href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.set" target="_blank" rel="noopener">__set()</a> 会被调用。</p>
<p>读取不可访问属性的值时，<a href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.get" target="_blank" rel="noopener">__get()</a> 会被调用。</p>
<p>当对不可访问属性调用 <a href="https://www.php.net/manual/zh/function.isset.php" target="_blank" rel="noopener">isset()</a> 或 <a href="https://www.php.net/manual/zh/function.empty.php" target="_blank" rel="noopener">empty()</a> 时，<a href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.isset" target="_blank" rel="noopener">__isset()</a> 会被调用。</p>
<p>当对不可访问属性调用 <a href="https://www.php.net/manual/zh/function.unset.php" target="_blank" rel="noopener">unset()</a> 时，<a href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.unset" target="_blank" rel="noopener">__unset()</a> 会被调用。</p>
<h4 id="方法重载">方法重载</h4>
<p>在对象中调用一个不可访问方法时，<a href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.call" target="_blank" rel="noopener">__call()</a> 会被调用。</p>
<p>在静态上下文中调用一个不可访问方法时，<a href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.callstatic" target="_blank" rel="noopener">__callStatic()</a> 会被调用。</p>
<h3 id="魔术方法">魔术方法</h3>
<h4 id="sleep-和-wakeup">__sleep()和__wakeup()</h4>
<p>序列化时先调用__sleep()方法。反序列话是wakeup方法。</p>
]]></content>
      <categories>
        <category>网络安全</category>
        <category>开发</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Web</tag>
      </tags>
  </entry>
</search>
